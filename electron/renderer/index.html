<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Vea æ§åˆ¶é¢</title>
    <link rel="stylesheet" href="theme-dark.css" id="theme-stylesheet">
    <style>
      .theme-toggle {
        margin-top: auto;
        padding: var(--space-md);
        border-top: 1px solid var(--border-color);
      }
    </style>
  </head>
  <body>
    <div class="titlebar">
      <div class="titlebar-title">
        <div class="titlebar-logo"></div>
        Vea Console
      </div>
      <div class="titlebar-controls">
        <div class="titlebar-button" id="minimize-btn">
          <svg width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
            <rect x="0" y="5" width="12" height="2"/>
          </svg>
        </div>
        <div class="titlebar-button" id="maximize-btn">
          <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1">
            <rect x="1" y="1" width="10" height="10"/>
          </svg>
        </div>
        <div class="titlebar-button close" id="close-btn">
          <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5">
            <line x1="1" y1="1" x2="11" y2="11"/>
            <line x1="11" y1="1" x2="1" y2="11"/>
          </svg>
        </div>
      </div>
    </div>
    <div class="app-container">
    <aside class="sidebar">
      <div class="brand">Vea Console</div>
      <nav class="menu" id="menu">
        <button data-target="panel-home" class="active">ä¸»é¡µ</button>
        <button data-target="panel1">èŠ‚ç‚¹</button>
        <button data-target="panel2">é…ç½®</button>
        <button data-target="panel3">æ ¸å¿ƒç»„ä»¶</button>
        <button data-target="panel4">æµé‡ç­–ç•¥</button>
        <button data-target="panel-settings">è®¾ç½®</button>
      </nav>
      <div class="theme-toggle">
        <button id="theme-toggle-btn" style="width: 100%;">ğŸŒ™ åˆ‡æ¢ä¸»é¢˜</button>
      </div>
    </aside>
    <main>
      <div id="status" class="status-bar"></div>

      <section id="panel-home" class="panel active">
        <header class="panel-header">
          <div>
            <h2>ä¸»é¡µ</h2>
            <p>æ€»è§ˆå½“å‰ä»£ç†çŠ¶æ€ä¸é€‰ä¸­èŠ‚ç‚¹çš„å®æ—¶ä¿¡æ¯ã€‚</p>
          </div>
        </header>

        <div class="card status-card">
          <div class="status-card-body">
            <h3>ä»£ç†æ§åˆ¶</h3>
            <div class="status-line">
              <span id="proxy-status" class="badge warn">æœªå®‰è£…</span>
              <span id="proxy-status-desc" class="muted">å°šæœªæ£€æµ‹åˆ°å¯ç”¨æ ¸å¿ƒï¼Œè¯·å…ˆå®‰è£…ã€‚</span>
            </div>
            <p class="muted note">è¯¥æ§åˆ¶åŒºä¼šè‡ªåŠ¨å®‰è£…ç¼ºå¤±æ ¸å¿ƒã€å¯åŠ¨ Xray å¹¶é…ç½®ç³»ç»Ÿä»£ç†ï¼Œå¿½ç•¥ä¸»æœºåˆ—è¡¨å¯åœ¨â€œè®¾ç½®â€ä¸­è°ƒæ•´ã€‚</p>
          </div>
          <div class="status-card-actions">
            <button type="button" class="primary" id="proxy-toggle" data-mode="">å¯åŠ¨ä»£ç†</button>
          </div>
        </div>

        <div class="card home-node-card">
          <h3>å½“å‰èŠ‚ç‚¹</h3>
          <div class="home-node-grid">
            <div>
              <span class="muted">åç§°</span>
              <div id="home-node-name">-</div>
            </div>
            <div>
              <span class="muted">åœ°å€</span>
              <div id="home-node-address">-</div>
            </div>
            <div>
              <span class="muted">å»¶è¿Ÿ</span>
              <div id="home-node-latency">~</div>
            </div>
            <div>
              <span class="muted">å¸¦å®½</span>
              <div id="home-node-speed">~</div>
            </div>
            <div>
              <span class="muted">æœ€åæ¢æµ‹</span>
              <div id="home-node-updated">-</div>
            </div>
          </div>
        </div>
      </section>

      <section id="panel1" class="panel">
        <header class="panel-header">
          <div>
            <h2>èŠ‚ç‚¹ç®¡ç†</h2>
            <p>æ³¨å†ŒèŠ‚ç‚¹ã€è·Ÿè¸ªæ¢æµ‹ç»“æœå¹¶å¤„ç†æµé‡ç»Ÿè®¡ã€‚æ ‡ç­¾ç”¨é€—å·åˆ†éš”ï¼Œåè®®è¾“å…¥éµå¾ªåç«¯å®šä¹‰ï¼ˆvlessã€trojanã€shadowsocksã€vmessï¼‰ã€‚</p>
          </div>
          <div class="panel-actions">
            <span id="xray-state" class="badge">æœªå®‰è£…</span>
            <button type="button" id="node-refresh" class="ghost">åˆ·æ–°</button>
          </div>
        </header>

        <div class="card node-toolbar">
          <div class="node-toolbar-left">
            <button type="button" id="node-add-button" class="add-node-button" title="æ–°å¢èŠ‚ç‚¹">+</button>
          </div>
          <div class="node-toolbar-actions">
            <button type="button" id="node-bulk-ping" class="ghost">å…¨éƒ¨å»¶è¿Ÿ</button>
            <button type="button" id="node-bulk-speed" class="ghost">å…¨éƒ¨æµ‹é€Ÿ</button>
          </div>
        </div>

        <div id="node-tabs" class="node-tabs"></div>

        <div id="node-grid" class="node-grid">
          <div class="empty-card">åŠ è½½ä¸­â€¦</div>
        </div>
      </section>

      <div id="node-modal" class="modal">
        <div class="modal-backdrop"></div>
        <div class="modal-content card">
          <button type="button" class="modal-close" id="node-modal-close" aria-label="å…³é—­">&times;</button>
          <form id="node-form" class="form-grid modal-form">
            <h3 style="grid-column: 1 / -1; margin-bottom: 8px;">æ–°å¢èŠ‚ç‚¹</h3>
            <label style="grid-column: 1 / -1">
              åˆ†äº«é“¾æ¥ï¼ˆvmess/vless/trojanï¼‰
              <input name="shareLink" type="text" placeholder="vmess://..." />
            </label>
            <label>
              åç§°
              <input name="name" type="text" placeholder="å¦‚ï¼šä¸œäº¬ 01" />
            </label>
            <label>
              åœ°å€
              <input name="address" type="text" placeholder="example.com" />
            </label>
            <label>
              ç«¯å£
              <input name="port" type="number" min="1" max="65535" value="443" />
            </label>
            <label>
              åè®®
              <select name="protocol">
                <option value="vless">vless</option>
                <option value="trojan">trojan</option>
                <option value="shadowsocks">shadowsocks</option>
                <option value="vmess">vmess</option>
              </select>
            </label>
            <label>
              æ ‡ç­¾ï¼ˆé€—å·åˆ†éš”ï¼‰
              <input name="tags" type="text" placeholder="premium,asia" />
            </label>
            <div class="form-actions modal-actions">
              <button type="reset" class="ghost" id="node-modal-reset">æ¸…ç©º</button>
              <button type="submit" class="primary">ä¿å­˜èŠ‚ç‚¹</button>
            </div>
          </form>
        </div>
      </div>

      <section id="panel2" class="panel">
        <header class="panel-header">
          <div>
            <h2>é…ç½®ä¸­å¿ƒ</h2>
            <p>å¯¼å…¥ xray ç­‰é…ç½®ï¼Œæ”¯æŒç›´æ¥ç²˜è´´ payload æˆ–æä¾› sourceUrl è‡ªåŠ¨æŠ“å–ï¼›åå°ä¼šæŒ‰ `autoUpdateIntervalMinutes` å®šæœŸåˆ·æ–°ã€‚</p>
          </div>
          <div class="panel-actions">
            <button type="button" id="config-refresh" class="ghost">åˆ·æ–°</button>
          </div>
        </header>

        <form id="config-form" class="card form-grid">
          <h3>æ–°å¢é…ç½®</h3>
          <label>
            åç§°
            <input name="name" type="text" placeholder="å¦‚ï¼šä¸œäº¬å…¥å£" required />
          </label>
          <label style="grid-column: 1 / -1">
            æº/è®¢é˜…é“¾æ¥
            <input name="sourceUrl" type="url" placeholder="https://example.com/config.json æˆ–è®¢é˜…åœ°å€" required />
          </label>
          <label>
            è‡ªåŠ¨æ›´æ–°é—´éš”ï¼ˆåˆ†é’Ÿï¼‰
            <input name="autoUpdateInterval" type="number" min="0" value="60" />
          </label>
          <label style="grid-column: 1 / -1">
            Payloadï¼ˆå¯é€‰ï¼Œç”¨äºç²˜è´´æœ¬åœ°é…ç½®ï¼‰
            <textarea name="payload" placeholder="{ &quot;outbounds&quot;: [] }"></textarea>
          </label>
          <div class="form-actions">
            <button type="reset" class="ghost">é‡ç½®</button>
            <button type="submit" class="primary">æ·»åŠ é…ç½®</button>
          </div>
        </form>

        <div class="card table-container">
          <table id="config-table">
            <thead>
              <tr>
                <th>åç§°</th>
                <th>æ ¼å¼</th>
                <th>æ›´æ–°é—´éš”</th>
                <th>ä¸Šæ¬¡åŒæ­¥</th>
                <th>çŠ¶æ€</th>
                <th>æ“ä½œ</th>
              </tr>
            </thead>
            <tbody>
              <tr><td colspan="6" class="empty">åŠ è½½ä¸­â€¦</td></tr>
            </tbody>
          </table>
        </div>
      </section>

            <section id="panel3" class="panel">
        <header class="panel-header">
          <div>
            <h2>æ ¸å¿ƒç»„ä»¶</h2>
            <p>ç®¡ç† Xray å†…æ ¸çš„ä¸‹è½½ä¸æ›´æ–°ï¼Œæ‰€æœ‰å†…å®¹è§£å‹åˆ° <code>artifacts/core</code>ï¼Œå®‰è£…æ—¶ä¼šè‡ªåŠ¨è¦†ç›–æ—§ç‰ˆæœ¬ã€‚</p>
          </div>
        </header>

        <div class="card">
          <h3>å†…æ ¸ç®¡ç†</h3>
          <div class="component-buttons">
            <div class="button-group">
              <button type="button" class="primary ensure-component" data-kind="xray">å®‰è£… / æ›´æ–° Xray</button>
              <button type="button" id="component-refresh" class="ghost">åˆ·æ–°åˆ—è¡¨</button>
            </div>
            <span class="muted">æŒ‰é’®ä¼šè‡ªåŠ¨è¡¥é½ç¼ºå¤±çš„ç»„ä»¶è®°å½•ï¼Œå¹¶ä» GitHub Release æ‹‰å–æœ€æ–°ç‰ˆæœ¬ã€‚</span>
          </div>
          <div class="table-container">
            <table id="component-table">
              <thead>
                <tr>
                  <th>åç§°</th>
                  <th>ç±»å‹</th>
                  <th>ç‰ˆæœ¬</th>
                  <th>å®‰è£…ç›®å½•</th>
                  <th>ä¸Šæ¬¡å®‰è£…</th>
                  <th>çŠ¶æ€</th>
                  <th>æ“ä½œ</th>
                </tr>
              </thead>
              <tbody>
                <tr><td colspan="7" class="empty">æš‚æ— ç»„ä»¶</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </section>


      <section id="panel4" class="panel">
        <header class="panel-header">
          <div>
            <h2>æµé‡ç­–ç•¥</h2>
            <p>é…ç½®é»˜è®¤å‡ºå£ã€DNS æ–¹æ¡ˆä»¥åŠåˆ†æµè§„åˆ™ã€‚DNS æœåŠ¡å™¨å¯ä½¿ç”¨é€—å·æˆ–æ¢è¡Œåˆ†éš”ã€‚</p>
          </div>
          <div class="panel-actions">
            <button type="button" id="traffic-refresh" class="ghost">åˆ·æ–°</button>
          </div>
        </header>

        <form id="profile-form" class="card form-grid">
          <h3>é»˜è®¤å‡ºå£ä¸ DNS</h3>
          <label>
            é»˜è®¤èŠ‚ç‚¹ IDï¼ˆå¯ç•™ç©ºï¼‰
            <input name="defaultNodeId" type="text" placeholder="èŠ‚ç‚¹ ID" />
          </label>
          <label>
            DNS ç­–ç•¥
            <input name="dnsStrategy" type="text" placeholder="ipv4-only / prefer-ipv6 ..." />
          </label>
          <label style="grid-column: 1 / -1">
            DNS æœåŠ¡å™¨
            <textarea name="dnsServers" placeholder="8.8.8.8, 1.1.1.1"></textarea>
          </label>
          <div class="form-actions">
            <button type="submit" class="primary">ä¿å­˜é…ç½®</button>
          </div>
        </form>

        <form id="rule-form" class="card form-grid">
          <h3>æ–°å¢åˆ†æµè§„åˆ™</h3>
          <label>
            åç§°
            <input name="name" type="text" placeholder="Netflix" required />
          </label>
          <label>
            ç›®æ ‡ï¼ˆé€—å·åˆ†éš”ï¼‰
            <input name="targets" type="text" placeholder="netflix.com, netflixcdn.com" required />
          </label>
          <label>
            èŠ‚ç‚¹ ID
            <input name="nodeId" type="text" placeholder="èŠ‚ç‚¹ ID" required />
          </label>
          <label>
            ä¼˜å…ˆçº§ï¼ˆæ•°å­—ï¼Œè¶Šå¤§è¶Šä¼˜å…ˆï¼‰
            <input name="priority" type="number" value="10" />
          </label>
          <div class="form-actions">
            <button type="reset" class="ghost">é‡ç½®</button>
            <button type="submit" class="primary">æ·»åŠ è§„åˆ™</button>
          </div>
        </form>

        <div class="card table-container">
          <table id="rule-table">
            <thead>
              <tr>
                <th>åç§°</th>
                <th>èŠ‚ç‚¹</th>
                <th>ç›®æ ‡</th>
                <th>ä¼˜å…ˆçº§</th>
                <th>æ›´æ–°æ—¶é—´</th>
                <th>æ“ä½œ</th>
              </tr>
            </thead>
            <tbody>
              <tr><td colspan="6" class="empty">åŠ è½½ä¸­â€¦</td></tr>
            </tbody>
          </table>
        </div>
      </section>

      <section id="panel-settings" class="panel">
        <header class="panel-header">
          <div>
            <h2>è®¾ç½®</h2>
            <p>ç®¡ç†ç³»ç»Ÿä»£ç†åŠå¿½ç•¥ä¸»æœºåˆ—è¡¨ï¼Œå¦‚éœ€æ›´å¤šé«˜çº§é€‰é¡¹å¯ç¼–è¾‘é…ç½®æ–‡ä»¶æˆ–æ‰‹åŠ¨è°ƒæ•´ç³»ç»Ÿè®¾ç½®ã€‚</p>
          </div>
        </header>

        <div class="card" id="system-proxy-card">
          <h3>ç³»ç»Ÿä»£ç†</h3>
          <p class="muted">æŒ‡å‘ <code>127.0.0.1:38087</code> çš„ SOCKS5 ä»£ç†ï¼Œæœ¬æœºåœ°å€ä¼šè¢«è‡ªåŠ¨å¿½ç•¥ã€‚</p>
          <div class="form-grid">
            <p class="muted" style="grid-column: 1 / -1">ä»£ç†å¼€å…³å·²ç§»åŠ¨åˆ°â€œä¸»é¡µâ€ï¼Œæ­¤å¤„ä»…ç»´æŠ¤å¿½ç•¥ä¸»æœºåˆ—è¡¨ã€‚</p>
            <label style="grid-column: 1 / -1">
              å¿½ç•¥ä¸»æœºï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰
              <textarea id="system-proxy-ignore" placeholder="localhost
127.0.0.0/8
::1"></textarea>
            </label>
            <div class="form-actions">
              <button type="button" class="ghost" id="system-proxy-reset">æ¢å¤é»˜è®¤</button>
              <button type="button" class="primary" id="system-proxy-save">ä¿å­˜</button>
            </div>
          </div>
        </div>
      </section>

    </main>
    <script type="module">
      import { createAPI, utils } from '../../sdk/dist/vea-sdk.esm.js';
      const { formatTime, formatBytes, formatInterval, escapeHtml, parseNumber, parseList, sleep } = utils;

      (function () {
        const menu = document.getElementById("menu");
        const panels = document.querySelectorAll(".panel");
        const statusBar = document.getElementById("status");
        let currentPanel = "panel-home";
        let statusTimer = null;

        const api = createAPI('');

        function showStatus(message, type = "info", delay = 3200) {
          if (!message) {
            statusBar.classList.remove("visible", "success", "error", "info");
            statusBar.textContent = "";
            return;
          }
          statusBar.textContent = message;
          statusBar.classList.remove("success", "error", "info");
          statusBar.classList.add("visible", type);
          if (statusTimer) {
            clearTimeout(statusTimer);
          }
          if (delay > 0) {
            statusTimer = setTimeout(() => {
              statusBar.classList.remove("visible");
            }, delay);
          }
        }

        const SYSTEM_PROXY_DEFAULTS = ["localhost", "127.0.0.0/8", "::1"];
        let systemProxySettings = {
          enabled: false,
          ignoreHosts: [...SYSTEM_PROXY_DEFAULTS],
        };
        const HOME_PING_COOLDOWN = 60000;
        const HOME_SPEEDTEST_COOLDOWN = 60000;
        const homePingState = {
          running: false,
          lastNodeId: "",
          lastTriggeredAt: 0,
        };
        const homeSpeedtestState = {
          running: false,
          lastNodeId: "",
          lastTriggeredAt: 0,
        };
        let nodeTags = [];
        let currentNodeTab = "å…¨éƒ¨";

let xrayStatus = {
  enabled: false,
  running: false,
  activeNodeId: "",
  binary: "",
};
let nodesCache = [];
let componentsCache = [];
let lastSelectedNodeId = "";
let preferredNodeId = "";
        let nodesPollHandle = null;
        const NODES_POLL_INTERVAL = 1000;

        function ensureNodesPolling() {
          if (nodesPollHandle) {
            return;
          }
          nodesPollHandle = setInterval(() => {
            loadNodes();
          }, NODES_POLL_INTERVAL);
        }

        async function refreshXrayStatus({ notify = false } = {}) {
          try {
            const status = await api.get("/xray/status");
            if ((!status || !status.binary) && componentsCache.length === 0) {
              try {
                const comps = await api.get("/components");
                componentsCache = Array.isArray(comps) ? comps : [];
              } catch {
                componentsCache = [];
              }
            }
            const normalized = {
              enabled: Boolean(status && status.enabled),
              running: Boolean(status && status.running),
              activeNodeId: (status && status.activeNodeId) || "",
              binary: (status && status.binary) || "",
              config: (status && status.config) || "",
            };
            xrayStatus = normalized;
            if (normalized.activeNodeId) {
              const exists = Array.isArray(nodesCache)
                ? nodesCache.find((item) => item && item.id === normalized.activeNodeId)
                : null;
              if (exists) {
                preferredNodeId = normalized.activeNodeId;
                activeNodeId = normalized.activeNodeId;
              }
            }
            updateXrayUI(normalized);
            updateHomeNodeStatus();
            if (notify) {
              const text = normalized.enabled
                ? normalized.running
                  ? "Xray å·²å¯åŠ¨"
                  : "Xray å·²å¯ç”¨"
                : "Xray å·²åœæ­¢";
              showStatus(text, "info");
            }
          } catch (err) {
            showStatus(`åŠ è½½ Xray çŠ¶æ€å¤±è´¥ï¼š${err.message}`, "error", 6000);
          }
        }

        function updateXrayUI(status = {}) {
          if (!status || typeof status !== "object") {
            status = {};
          }
          const indicator = document.getElementById("xray-state");
          const proxyStatus = document.getElementById("proxy-status");
          const proxyDesc = document.getElementById("proxy-status-desc");
          const proxyToggle = document.getElementById("proxy-toggle");
          const xrayComponent = Array.isArray(componentsCache)
            ? componentsCache.find((component) => component && component.kind === "xray")
            : null;

          let binaryCandidate = typeof status.binary === "string" ? status.binary.trim() : "";
          if (!binaryCandidate && xrayComponent) {
            const meta = xrayComponent.meta || {};
            if (typeof meta.binary === "string" && meta.binary.trim() != "") {
              binaryCandidate = meta.binary.trim();
            } else if (typeof xrayComponent.installDir === "string" && xrayComponent.installDir.trim() != "") {
              binaryCandidate = `${xrayComponent.installDir.replace(/\/$/, "")}/xray`;
            }
          }
          if (!binaryCandidate) {
            binaryCandidate = "artifacts/core/xray/xray";
          }
          status.binary = binaryCandidate;
          const hasBinary = Boolean(binaryCandidate);

          if (indicator) {
            if (!hasBinary) {
              indicator.className = "badge warn";
              indicator.textContent = "æœªå®‰è£…";
            } else if (status.enabled) {
              indicator.className = status.running ? "badge active" : "badge warn";
              indicator.textContent = status.running ? "è¿è¡Œä¸­" : "å·²å¯ç”¨";
            } else {
              indicator.className = "badge";
              indicator.textContent = "å·²åœæ­¢";
            }
          }

          const proxyEnabled = Boolean(systemProxySettings && systemProxySettings.enabled);
          if (!proxyStatus && !proxyToggle && !proxyDesc) {
            return;
          }

          if (!hasBinary) {
            if (proxyStatus) {
              proxyStatus.className = "badge warn";
              proxyStatus.textContent = "æœªå®‰è£…";
            }
            if (proxyDesc) {
              proxyDesc.textContent = "å°šæœªæ£€æµ‹åˆ°å¯ç”¨æ ¸å¿ƒï¼Œè¯·å…ˆå®‰è£… Xrayã€‚";
            }
            if (proxyToggle) {
              proxyToggle.disabled = true;
              proxyToggle.dataset.mode = "";
              proxyToggle.classList.remove("danger");
              proxyToggle.classList.add("primary");
              proxyToggle.textContent = "å¯åŠ¨ä»£ç†";
            }
            return;
          }

          if (proxyStatus) {
            if (status.enabled && status.running && proxyEnabled) {
              proxyStatus.className = "badge active";
              proxyStatus.textContent = "è¿è¡Œä¸­";
              if (proxyDesc) {
                proxyDesc.textContent = "ç³»ç»Ÿä»£ç†å·²æŒ‡å‘ 127.0.0.1:38087ã€‚";
              }
            } else if (status.enabled && !proxyEnabled) {
              proxyStatus.className = "badge warn";
              proxyStatus.textContent = "æ ¸å¿ƒè¿è¡Œ";
              if (proxyDesc) {
                proxyDesc.textContent = "æ ¸å¿ƒå·²è¿è¡Œï¼Œç³»ç»Ÿä»£ç†å°šæœªå¯ç”¨ã€‚";
              }
            } else if (status.enabled) {
              proxyStatus.className = "badge warn";
              proxyStatus.textContent = "æ ¸å¿ƒå¾…è¿è¡Œ";
              if (proxyDesc) {
                proxyDesc.textContent = "æ ¸å¿ƒæ­£åœ¨å¯åŠ¨ï¼Œè¯·ç¨å€™ã€‚";
              }
            } else {
              proxyStatus.className = "badge";
              proxyStatus.textContent = "å·²åœæ­¢";
              if (proxyDesc) {
                proxyDesc.textContent = "ç‚¹å‡»å¯åŠ¨ä»£ç†å³å¯å¯åŠ¨æ ¸å¿ƒå¹¶åˆ‡æ¢ç³»ç»Ÿä»£ç†ã€‚";
              }
            }
          }

          if (proxyToggle) {
            proxyToggle.disabled = false;
            proxyToggle.classList.remove("primary", "danger");
            if (status.enabled && proxyEnabled) {
              proxyToggle.dataset.mode = "stop";
              proxyToggle.classList.add("danger");
              proxyToggle.textContent = "åœæ­¢ä»£ç†";
            } else {
              proxyToggle.dataset.mode = "start";
              proxyToggle.classList.add("primary");
              proxyToggle.textContent = "å¯åŠ¨ä»£ç†";
            }
          }
        }

        // Panel loaders
        let activeNodeId = "";

        async function loadNodes({ notify = false } = {}) {
          try {
            const payload = await api.get("/nodes");
            const nodes = Array.isArray(payload.nodes) ? payload.nodes : [];
            const serverActiveNodeId = typeof payload.activeNodeId === "string" ? payload.activeNodeId : "";
            const recentSelectedId = typeof payload.lastSelectedNodeId === "string" ? payload.lastSelectedNodeId : "";
            nodesCache = nodes;
            lastSelectedNodeId = recentSelectedId;

            const hasNode = (id) => !!id && nodes.some((node) => node && node.id === id);
            if (hasNode(recentSelectedId)) {
              preferredNodeId = recentSelectedId;
            } else if (hasNode(serverActiveNodeId)) {
              preferredNodeId = serverActiveNodeId;
            } else if (nodes.length > 0 && nodes[0] && nodes[0].id) {
              preferredNodeId = nodes[0].id;
            } else {
              preferredNodeId = "";
            }

            activeNodeId = serverActiveNodeId || preferredNodeId;
            updateNodeTabs(nodes);
            renderNodes(nodes, activeNodeId);
            updateHomeNodeStatus();
            refreshXrayStatus();
            if (notify) {
              showStatus("èŠ‚ç‚¹åˆ—è¡¨å·²åˆ·æ–°", "success");
            }
            if (currentPanel === "panel-home") {
              autoMeasureCurrentNode();
            }
          } catch (err) {
            showStatus(`åŠ è½½èŠ‚ç‚¹å¤±è´¥ï¼š${err.message}`, "error", 6000);
            nodesCache = [];
            updateHomeNodeStatus();
          }
        }

        function updateNodeTabs(nodes) {
          if (!nodeTabs) return;
          const tags = new Set();
          nodes.forEach((node) => {
            if (Array.isArray(node.tags)) {
              node.tags.forEach((tag) => {
                const trimmed = String(tag || "").trim();
                if (trimmed) {
                  tags.add(trimmed);
                }
              });
            }
          });
          const sorted = ["å…¨éƒ¨", ...Array.from(tags).sort((a, b) => a.localeCompare(b, "zh-Hans-CN"))];
          nodeTags = sorted;
          if (!nodeTags.includes(currentNodeTab)) {
            currentNodeTab = "å…¨éƒ¨";
          }
          nodeTabs.innerHTML = nodeTags
            .map((tag) => {
              const active = tag === currentNodeTab ? "active" : "";
              return `<button type="button" class="node-tab ${active}" data-tag="${escapeHtml(tag)}">${escapeHtml(tag)}</button>`;
            })
            .join("");
        }

        function renderNodes(nodes, currentId = "") {
          if (!nodeGrid) return;
          let filtered = nodes;
          if (currentNodeTab !== "å…¨éƒ¨") {
            filtered = nodes.filter((node) => Array.isArray(node.tags) && node.tags.includes(currentNodeTab));
          }
          if (!Array.isArray(nodes) || nodes.length === 0) {
            nodeGrid.innerHTML = '<div class="empty-card">æš‚æ— èŠ‚ç‚¹</div>';
            return;
          }

          if (!Array.isArray(filtered) || filtered.length === 0) {
            nodeGrid.innerHTML = '<div class="empty-card">å½“å‰æ ‡ç­¾ä¸‹æš‚æ— èŠ‚ç‚¹</div>';
            return;
          }

          nodeGrid.innerHTML = filtered
            .map((node) => {
              const rowId = escapeHtml(node.id);
              const isActive = currentId && node.id === currentId;
              const protocolBadges = [`<span class="badge">${escapeHtml(node.protocol)}</span>`]
                .filter(Boolean)
                .join(" ");
              const latencyValue =
                typeof node.lastLatencyMs === "number" && node.lastLatencyMs > 0 ? `${node.lastLatencyMs} ms` : "æµ‹å»¶è¿Ÿ";
              let speedValue;
              if (typeof node.lastSpeedError === "string" && node.lastSpeedError) {
                speedValue = "æµ‹é€Ÿå¤±è´¥";
              } else if (typeof node.lastSpeedMbps === "number" && node.lastSpeedMbps > 0) {
                const fixed = node.lastSpeedMbps >= 10 ? node.lastSpeedMbps.toFixed(1) : node.lastSpeedMbps.toFixed(2);
                speedValue = `${fixed} MB/s`;
              } else {
                speedValue = "æµ‹é€Ÿ";
              }
              return `
                <div class="node-card ${isActive ? "active-node" : ""}" data-id="${rowId}">
                  <div class="node-card-header">
                    <div>
                      <div class="node-card-title">${escapeHtml(node.name)}</div>
                      <div class="node-card-address">${escapeHtml(node.address)}:${escapeHtml(node.port)}</div>
                      <div class="node-card-badges">${protocolBadges}</div>
                    </div>
                    <div class="node-card-controls"></div>
                  </div>
                  <div class="node-metrics">
                    <span data-action="ping-node">${escapeHtml(latencyValue)}</span>
                    <span data-action="speed-node">${escapeHtml(speedValue)}</span>
                  </div>
                  <div class="node-actions">
                    <button class="danger" data-action="delete-node">åˆ é™¤</button>
                  </div>
                </div>
              `;
            })
            .join("");
        }

        async function loadConfigs({ notify = false } = {}) {
          try {
            const configs = await api.get("/configs");
            renderConfigs(configs);
            if (notify) {
              showStatus("é…ç½®åˆ—è¡¨å·²åˆ·æ–°", "success");
            }
          } catch (err) {
            showStatus(`åŠ è½½é…ç½®å¤±è´¥ï¼š${err.message}`, "error", 6000);
          }
        }

        function renderConfigs(configs) {
          const tbody = document.querySelector("#config-table tbody");
          if (!Array.isArray(configs) || configs.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" class="empty">æš‚æ— é…ç½®</td></tr>';
            return;
          }
          tbody.innerHTML = configs
            .map((cfg) => {
              const syncState = cfg.lastSyncError
                ? `<span class="badge error">å¤±è´¥ï¼š${escapeHtml(cfg.lastSyncError)}</span>`
                : '<span class="badge">æ­£å¸¸</span>';
              const source = cfg.sourceUrl ? `<br /><span class="muted text-break">${escapeHtml(cfg.sourceUrl)}</span>` : "";
              return `
                <tr data-id="${escapeHtml(cfg.id)}">
                  <td>${escapeHtml(cfg.name)}${source}</td>
                  <td><span class="badge">${escapeHtml(cfg.format)}</span></td>
                  <td>${formatInterval(cfg.autoUpdateInterval)}</td>
                  <td>${formatTime(cfg.lastSyncedAt)}</td>
                  <td>${syncState}</td>
                  <td>
                    <button class="ghost" data-action="pull-nodes">æ‹‰å–èŠ‚ç‚¹</button>
                    <button class="ghost" data-action="refresh-config">åˆ·æ–°</button>
                    <button class="danger" data-action="delete-config">åˆ é™¤</button>
                  </td>
                </tr>
              `;
            })
            .join("");
        }

        function renderSystemProxy(settings) {
          if (!systemProxyIgnoreInput) return;
          const hosts = Array.isArray(settings.ignoreHosts) ? settings.ignoreHosts : [];
          systemProxyIgnoreInput.value = hosts.join("\n");
        }

        async function loadSystemProxySettings({ notify = false } = {}) {
          if (!systemProxyIgnoreInput) return;
          try {
            const payload = await api.get("/settings/system-proxy");
            const data = payload && payload.settings ? payload.settings : payload;
            systemProxySettings = {
              enabled: Boolean(data.enabled),
              ignoreHosts: Array.isArray(data.ignoreHosts) ? data.ignoreHosts : [...SYSTEM_PROXY_DEFAULTS],
            };
            renderSystemProxy(systemProxySettings);
            updateXrayUI(xrayStatus);
            if (notify) {
              const msg = payload && payload.message ? payload.message : "ç³»ç»Ÿä»£ç†è®¾ç½®å·²åˆ·æ–°";
              showStatus(msg, payload && payload.message ? "info" : "success");
            }
          } catch (err) {
            showStatus(`åŠ è½½ç³»ç»Ÿä»£ç†å¤±è´¥ï¼š${err.message}`, "error", 6000);
          }
        }

        function collectIgnoreHosts() {
          if (!systemProxyIgnoreInput) {
            return Array.isArray(systemProxySettings.ignoreHosts)
              ? [...systemProxySettings.ignoreHosts]
              : [...SYSTEM_PROXY_DEFAULTS];
          }
          return systemProxyIgnoreInput
            .value.split(/\r?\n/)
            .map((item) => item.trim())
            .filter(Boolean);
        }

        function updateHomeNodeStatus() {
          if (!homeNodeName || !homeNodeAddress || !homeNodeLatency || !homeNodeSpeed || !homeNodeUpdated) return;
          let node = null;
          if (Array.isArray(nodesCache) && nodesCache.length > 0) {
            const targetId = resolveHomeNodeId();
            if (targetId) {
              node = nodesCache.find((item) => item.id === targetId) || null;
            }
            if (!node) {
              node = nodesCache[0];
            }
          }
          if (!node) {
            homeNodeName.textContent = "-";
            homeNodeAddress.textContent = "-";
            homeNodeLatency.textContent = "~";
            homeNodeSpeed.textContent = "~";
            homeNodeUpdated.textContent = "-";
            return;
          }

          homeNodeName.textContent = escapeHtml(node.name || "-");
          homeNodeAddress.textContent = node.address ? `${escapeHtml(node.address)}:${escapeHtml(String(node.port || ""))}` : "-";

          const latency = typeof node.lastLatencyMs === "number" && node.lastLatencyMs > 0 ? `${node.lastLatencyMs} ms` : "~";
          let speed;
          if (node.lastSpeedError) {
            speed = `å¤±è´¥ ${escapeHtml(node.lastSpeedError)}`;
          } else if (typeof node.lastSpeedMbps === "number" && node.lastSpeedMbps > 0) {
            speed = `${node.lastSpeedMbps >= 10 ? node.lastSpeedMbps.toFixed(1) : node.lastSpeedMbps.toFixed(2)} MB/s`;
          } else {
            speed = "~";
          }
          homeNodeLatency.textContent = latency;
          homeNodeSpeed.textContent = speed;

        const timestamps = [node.lastLatencyAt, node.lastSpeedAt].filter(Boolean);
        const updated = timestamps.length > 0 ? timestamps.sort().slice(-1)[0] : null;
        homeNodeUpdated.textContent = updated ? formatTime(updated) : "-";
      }

      function resolveHomeNodeId() {
        if (!Array.isArray(nodesCache) || nodesCache.length === 0) {
          return "";
        }
        if (xrayStatus && xrayStatus.activeNodeId) {
          const active = nodesCache.find((item) => item.id === xrayStatus.activeNodeId);
          if (active && active.id) {
            return active.id;
          }
        }
        if (preferredNodeId) {
          const preferred = nodesCache.find((item) => item.id === preferredNodeId);
          if (preferred && preferred.id) {
            return preferred.id;
          }
        }
        const first = nodesCache[0];
        return (first && first.id) || "";
      }

      async function autoPingCurrentNode(targetId, { force = false } = {}) {
        const nodeId = targetId || resolveHomeNodeId();
        if (!nodeId) {
          return false;
        }
        const now = Date.now();
        if (!force) {
          if (homePingState.running && now - homePingState.lastTriggeredAt < HOME_PING_COOLDOWN) {
            return false;
          }
          if (homePingState.lastNodeId === nodeId && now - homePingState.lastTriggeredAt < HOME_PING_COOLDOWN) {
            return false;
          }
          const node = Array.isArray(nodesCache) ? nodesCache.find((item) => item.id === nodeId) : null;
          if (node) {
            const lastLatencyAt = node.lastLatencyAt ? Date.parse(node.lastLatencyAt) : NaN;
            if (!Number.isNaN(lastLatencyAt) && now - lastLatencyAt < HOME_PING_COOLDOWN) {
              return false;
            }
          }
        }
        homePingState.running = true;
        homePingState.lastNodeId = nodeId;
        homePingState.lastTriggeredAt = now;
        try {
          await api.post(`/nodes/${nodeId}/ping`);
          return true;
        } catch (err) {
          showStatus(`å»¶è¿Ÿä»»åŠ¡å¤±è´¥ï¼š${err.message}`, "error", 6000);
          return false;
        } finally {
          homePingState.running = false;
        }
      }

      async function autoSpeedtestCurrentNode(targetId, { force = false } = {}) {
        const nodeId = targetId || resolveHomeNodeId();
        if (!nodeId) {
          return false;
        }
        const now = Date.now();
        if (!force) {
          if (homeSpeedtestState.running && now - homeSpeedtestState.lastTriggeredAt < HOME_SPEEDTEST_COOLDOWN) {
            return false;
          }
          if (homeSpeedtestState.lastNodeId === nodeId && now - homeSpeedtestState.lastTriggeredAt < HOME_SPEEDTEST_COOLDOWN) {
            return false;
          }
          const node = Array.isArray(nodesCache) ? nodesCache.find((item) => item.id === nodeId) : null;
          if (node && (!node.lastSpeedError || node.lastSpeedError.length === 0)) {
            const lastSpeedAt = node.lastSpeedAt ? Date.parse(node.lastSpeedAt) : NaN;
            if (!Number.isNaN(lastSpeedAt) && now - lastSpeedAt < HOME_SPEEDTEST_COOLDOWN) {
              return false;
            }
          }
        }
        homeSpeedtestState.running = true;
        homeSpeedtestState.lastNodeId = nodeId;
        homeSpeedtestState.lastTriggeredAt = now;
        try {
          await api.post(`/nodes/${nodeId}/speedtest`);
          return true;
        } catch (err) {
          showStatus(`æµ‹é€Ÿä»»åŠ¡å¤±è´¥ï¼š${err.message}`, "error", 6000);
          return false;
        } finally {
          homeSpeedtestState.running = false;
        }
      }

      async function autoMeasureCurrentNode({ force = false } = {}) {
        const targetId = resolveHomeNodeId();
        if (!targetId) {
          return;
        }
        const pingTriggered = await autoPingCurrentNode(targetId, { force });
        if (pingTriggered) {
          await sleep(200);
        }
        await autoSpeedtestCurrentNode(targetId, { force });
      }

        async function loadHomePanel({ notify = false } = {}) {
          await Promise.all([loadComponents(), refreshXrayStatus({ notify }), loadSystemProxySettings({ notify })]);
          updateHomeNodeStatus();
          await autoMeasureCurrentNode({ force: true });
        }

        async function handleProxyToggle() {
          if (!proxyToggleButton || proxyToggleButton.disabled) return;
          const mode = proxyToggleButton.dataset.mode || "start";
          proxyToggleButton.disabled = true;
          try {
            if (mode === "stop") {
              await api.put("/settings/system-proxy", {
                enabled: false,
                ignoreHosts: collectIgnoreHosts(),
              });
              await api.post("/xray/stop");
              showStatus("ä»£ç†å·²åœæ­¢", "info");
            } else {
              const payload = {};
              if (activeNodeId) {
                payload.activeNodeId = activeNodeId;
              }
              if (Object.keys(payload).length > 0) {
                await api.post("/xray/start", payload);
              } else {
                await api.post("/xray/start");
              }
              const response = await api.put("/settings/system-proxy", {
                enabled: true,
                ignoreHosts: collectIgnoreHosts(),
              });
              const msg = response && response.message ? response.message : "ä»£ç†å·²å¯åŠ¨";
              showStatus(msg, response && response.message ? "info" : "success");
            }
          } catch (err) {
            showStatus(`ä»£ç†æ“ä½œå¤±è´¥ï¼š${err.message}`, "error", 6000);
          } finally {
            proxyToggleButton.disabled = false;
            await refreshXrayStatus();
            await loadSystemProxySettings();
          }
        }

        function renderComponents(components) {
          const tbody = document.querySelector("#component-table tbody");
          if (!tbody) return;
          if (!Array.isArray(components) || components.length === 0) {
            tbody.innerHTML = '<tr><td colspan="7" class="empty">æš‚æ— ç»„ä»¶</td></tr>';
            return;
          }
          tbody.innerHTML = components
            .map((component) => {
              const id = escapeHtml(component.id || "");
              const name = escapeHtml(component.name || "-");
              const kind = escapeHtml(componentDisplayName(component.kind));
              const version = escapeHtml(component.lastVersion || "-");
              const installDir = escapeHtml(component.installDir || "-");
              const installedAt = formatTime(component.lastInstalledAt);
              let statusText;
              if (component.lastSyncError) {
                statusText = `<span class="badge error">å¤±è´¥ï¼š${escapeHtml(component.lastSyncError)}</span>`;
              } else if (component.installDir) {
                statusText = '<span class="badge">å·²å®‰è£…</span>';
              } else {
                statusText = '<span class="badge warn">æœªå®‰è£…</span>';
              }
              const interval = formatInterval(component.autoUpdateInterval);
              return `
                <tr data-id="${id}">
                  <td>${name}</td>
                  <td><span class="badge">${kind}</span></td>
                  <td>${version}</td>
                  <td><span class="muted">${installDir}</span></td>
                  <td>${installedAt}</td>
                  <td>${statusText}<br /><span class="muted">è‡ªåŠ¨æ›´æ–°ï¼š${interval}</span></td>
                  <td>
                    <button class="danger" data-action="delete-component">åˆ é™¤</button>
                  </td>
                </tr>
              `;
            })
            .join("");
        }

        async function loadComponents({ notify = false } = {}) {
          try {
            const components = await api.get("/components");
            componentsCache = Array.isArray(components) ? components : [];
            renderComponents(components);
            await refreshXrayStatus();
            if (notify) {
              showStatus("ç»„ä»¶åˆ—è¡¨å·²åˆ·æ–°", "success");
            }
          } catch (err) {
            showStatus(`åŠ è½½ç»„ä»¶å¤±è´¥ï¼š${err.message}`, "error", 6000);
            componentsCache = [];
            await refreshXrayStatus();
          }
        }

        function componentDisplayName(kind) {
          switch (kind) {
            case "xray":
              return "Xray";
            default:
              return kind || "ç»„ä»¶";
          }
        }

        async function ensureComponent(kind) {
          const pretty = componentDisplayName(kind);
          try {
            let components = [];
            try {
              components = await api.get("/components");
            } catch {
              components = [];
            }
            componentsCache = Array.isArray(components) ? components : [];
            let target = Array.isArray(components) ? components.find((item) => item.kind === kind) : null;
            if (!target) {
              target = await api.post("/components", { kind });
            }
            await api.post(`/components/${target.id}/install`);
            showStatus(`${pretty} å®‰è£…ä»»åŠ¡å·²è§¦å‘`, "info", 2400);
            await loadComponents();
            await refreshXrayStatus();
          } catch (err) {
            showStatus(`${pretty} å®‰è£…å¤±è´¥ï¼š${err.message}`, "error", 6000);
          }
        }

        async function loadTraffic({ notify = false } = {}) {
          try {
            const [profile, rules] = await Promise.all([api.get("/traffic/profile"), api.get("/traffic/rules")]);
            renderTrafficProfile(profile);
            renderTrafficRules(rules);
            if (notify) {
              showStatus("æµé‡ç­–ç•¥å·²åˆ·æ–°", "success");
            }
          } catch (err) {
            showStatus(`åŠ è½½æµé‡ç­–ç•¥å¤±è´¥ï¼š${err.message}`, "error", 6000);
          }
        }

        function renderTrafficProfile(profile) {
          const form = document.getElementById("profile-form");
          form.defaultNodeId.value = profile.defaultNodeId || "";
          form.dnsStrategy.value = (profile.dns && profile.dns.strategy) || "";
          form.dnsServers.value = (profile.dns && profile.dns.servers ? profile.dns.servers.join("\n") : "");
        }

        function renderTrafficRules(rules) {
          const tbody = document.querySelector("#rule-table tbody");
          if (!Array.isArray(rules) || rules.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" class="empty">æš‚æ— è§„åˆ™</td></tr>';
            return;
          }
          tbody.innerHTML = rules
            .map((rule) => {
              const targets =
                Array.isArray(rule.targets) && rule.targets.length
                  ? rule.targets.map((target) => `<span class="tag">${escapeHtml(target)}</span>`).join("")
                  : '<span class="muted">-</span>';
              return `
                <tr data-id="${escapeHtml(rule.id)}">
                  <td>${escapeHtml(rule.name)}</td>
                  <td>${escapeHtml(rule.nodeId)}</td>
                  <td><div class="tags">${targets}</div></td>
                  <td>${escapeHtml(rule.priority ?? "-")}</td>
                  <td>${formatTime(rule.updatedAt)}</td>
                  <td>
                    <button class="danger" data-action="delete-rule">åˆ é™¤</button>
                  </td>
                </tr>
              `;
            })
            .join("");
        }

        const loaders = {
          "panel-home": () => loadHomePanel(),
          panel1: loadNodes,
          panel2: loadConfigs,
          panel3: () => loadComponents(),
          panel4: loadTraffic,
          "panel-settings": () => loadSystemProxySettings(),
        };

        menu.addEventListener("click", (event) => {
          const button = event.target.closest("button[data-target]");
          if (!button) return;
          const target = button.dataset.target;
          if (target === currentPanel) return;
          currentPanel = target;
          menu.querySelectorAll("button").forEach((btn) => btn.classList.remove("active"));
          button.classList.add("active");
          panels.forEach((panel) => {
            panel.classList.toggle("active", panel.id === target);
          });
          loaders[target]?.();
        });

        const nodeGrid = document.getElementById("node-grid");
        const nodeTabs = document.getElementById("node-tabs");
        const nodeAddButton = document.getElementById("node-add-button");
        const nodeModal = document.getElementById("node-modal");
        const nodeModalClose = document.getElementById("node-modal-close");
        const nodeModalReset = document.getElementById("node-modal-reset");
        const nodeModalBackdrop = nodeModal ? nodeModal.querySelector(".modal-backdrop") : null;
        const nodeForm = document.getElementById("node-form");
        document.getElementById("node-refresh").addEventListener("click", () => loadNodes({ notify: true }));
        document.getElementById("config-refresh").addEventListener("click", () => loadConfigs({ notify: true }));
        document.getElementById("traffic-refresh").addEventListener("click", () => loadTraffic({ notify: true }));
        document.getElementById("component-refresh").addEventListener("click", () => loadComponents({ notify: true }));
        const systemProxyIgnoreInput = document.getElementById("system-proxy-ignore");
        const systemProxySaveButton = document.getElementById("system-proxy-save");
        const systemProxyResetButton = document.getElementById("system-proxy-reset");
        const proxyToggleButton = document.getElementById("proxy-toggle");
        const homeNodeName = document.getElementById("home-node-name");
        const homeNodeAddress = document.getElementById("home-node-address");
        const homeNodeLatency = document.getElementById("home-node-latency");
        const homeNodeSpeed = document.getElementById("home-node-speed");
        const homeNodeUpdated = document.getElementById("home-node-updated");
        if (proxyToggleButton) {
          proxyToggleButton.addEventListener("click", handleProxyToggle);
        }

        function openNodeModal() {
          if (!nodeModal) return;
          nodeModal.classList.add("open");
        }

        function closeNodeModal() {
          if (!nodeModal) return;
          nodeModal.classList.remove("open");
        }

        if (nodeAddButton) {
          nodeAddButton.addEventListener("click", openNodeModal);
        }
        if (nodeModalClose) {
          nodeModalClose.addEventListener("click", closeNodeModal);
        }
        if (nodeModalBackdrop) {
          nodeModalBackdrop.addEventListener("click", closeNodeModal);
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape" && nodeModal?.classList.contains("open")) {
            closeNodeModal();
          }
        });
        if (nodeModalReset && nodeForm) {
          nodeModalReset.addEventListener("click", () => {
            nodeForm.reset();
          });
        }

        if (nodeForm) {
          nodeForm.addEventListener("submit", async (event) => {
            event.preventDefault();
            const form = event.target;
            const shareLink = form.shareLink.value.trim();
            if (shareLink) {
              try {
                await api.post("/nodes", { shareLink });
                form.reset();
                showStatus("èŠ‚ç‚¹æ·»åŠ æˆåŠŸ", "success");
                await loadNodes();
                closeNodeModal();
              } catch (err) {
                showStatus(`æ·»åŠ èŠ‚ç‚¹å¤±è´¥ï¼š${err.message}`, "error", 6000);
              }
              return;
            }
            const payload = {
              name: form.name.value.trim(),
              address: form.address.value.trim(),
              port: parseNumber(form.port.value),
              protocol: form.protocol.value.trim(),
              tags: parseList(form.tags.value),
            };
            if (!payload.name || !payload.address || !payload.protocol || !payload.port) {
              showStatus("è¯·å®Œæ•´å¡«å†™èŠ‚ç‚¹ä¿¡æ¯", "error");
              return;
            }
            try {
              await api.post("/nodes", payload);
              form.reset();
              showStatus("èŠ‚ç‚¹æ·»åŠ æˆåŠŸ", "success");
              await loadNodes();
              closeNodeModal();
            } catch (err) {
              showStatus(`æ·»åŠ èŠ‚ç‚¹å¤±è´¥ï¼š${err.message}`, "error", 6000);
            }
          });
        }

        if (nodeGrid) {
          nodeGrid.addEventListener("click", async (event) => {
            const card = event.target.closest(".node-card[data-id]");
            if (!card) return;
            const id = card.dataset.id;
            const actionTarget = event.target.closest("[data-action]");
            const action = actionTarget ? actionTarget.dataset.action : "select-node";
            try {
              if (action === "delete-node") {
                if (!confirm("ç¡®è®¤åˆ é™¤è¯¥èŠ‚ç‚¹ï¼Ÿ")) return;
                await api.delete(`/nodes/${id}`);
                showStatus("èŠ‚ç‚¹å·²åˆ é™¤", "success");
                await loadNodes();
              } else if (action === "ping-node") {
                await api.post(`/nodes/${id}/ping`);
                showStatus("å»¶è¿Ÿä»»åŠ¡å·²æ’é˜Ÿ", "info");
                await loadNodes();
              } else if (action === "speed-node") {
                await api.post(`/nodes/${id}/speedtest`);
                showStatus("æµ‹é€Ÿä»»åŠ¡å·²æ’é˜Ÿ", "info");
                await loadNodes();
              } else if (action === "select-node") {
                await api.post(`/nodes/${id}/select`);
                showStatus("å·²åˆ‡æ¢å½“å‰èŠ‚ç‚¹", "success");
                await loadNodes();
              }
            } catch (err) {
              showStatus(`æ“ä½œå¤±è´¥ï¼š${err.message}`, "error", 6000);
            }
          });
        }

        if (nodeTabs) {
          nodeTabs.addEventListener("click", (event) => {
            const button = event.target.closest(".node-tab[data-tag]");
            if (!button) return;
            const tag = button.dataset.tag;
            if (tag === currentNodeTab) return;
            currentNodeTab = tag;
            nodeTabs.querySelectorAll(".node-tab").forEach((tab) => tab.classList.remove("active"));
            button.classList.add("active");
            renderNodes(nodesCache, activeNodeId);
          });
        }

        document.getElementById("config-form").addEventListener("submit", async (event) => {
          event.preventDefault();
          const form = event.target;
          let inferredFormat = "";
          const typedPayload = (form.payload.value || "").trim();
          const sourceUrl = form.sourceUrl.value.trim();
          const detectSample = typedPayload || sourceUrl;
          if (detectSample) {
            const lower = detectSample.toLowerCase();
            if (/\"outbounds\"/.test(detectSample) || /\"inbounds\"/.test(detectSample) || /vmess|trojan|vless|ss:/.test(lower)) {
              inferredFormat = "xray-json";
            }
          }
          const payload = {
            name: form.name.value.trim(),
            format: inferredFormat || "xray-json",
            sourceUrl,
            payload: typedPayload,
            autoUpdateIntervalMinutes: parseNumber(form.autoUpdateInterval.value),
          };
          if (!payload.sourceUrl) {
            showStatus("è¯·å¡«å†™æº/è®¢é˜…é“¾æ¥", "error", 5000);
            return;
          }
          try {
            await api.post("/configs/import", payload);
            form.reset();
            showStatus("é…ç½®æ·»åŠ æˆåŠŸ", "success");
            await Promise.all([loadConfigs(), loadNodes()]);
          } catch (err) {
            showStatus(`æ·»åŠ é…ç½®å¤±è´¥ï¼š${err.message}`, "error", 6000);
          }
        });

        function getSelectedNodeIds() {
          if (!nodeGrid) return [];
          return Array.from(nodeGrid.querySelectorAll(".node-card[data-id]"))
            .map((card) => card.dataset.id)
            .filter(Boolean);
        }

        document.getElementById("node-bulk-ping").addEventListener("click", async () => {
          const ids = getSelectedNodeIds();
          if (ids.length === 0) {
            showStatus("è¯·å…ˆå‹¾é€‰èŠ‚ç‚¹", "error");
            return;
          }
          try {
            await api.post("/nodes/bulk/ping", { ids });
            showStatus("æ‰¹é‡å»¶è¿Ÿä»»åŠ¡å·²æ’é˜Ÿ", "info");
            await loadNodes();
          } catch (err) {
            showStatus(`æ‰¹é‡å»¶è¿Ÿå¤±è´¥ï¼š${err.message}`, "error", 6000);
          }
        });

        document.getElementById("node-bulk-speed").addEventListener("click", async () => {
          const ids = getSelectedNodeIds();
          if (ids.length === 0) {
            showStatus("è¯·å…ˆå‹¾é€‰èŠ‚ç‚¹", "error");
            return;
          }
          try {
            await api.post("/nodes/reset-speed", { ids });
            await loadNodes();
            for (const id of ids) {
              await api.post(`/nodes/${id}/speedtest`);
            }
            showStatus("æ‰¹é‡æµ‹é€Ÿä»»åŠ¡å·²æ’é˜Ÿ", "info");
            await loadNodes();
          } catch (err) {
            showStatus(`æ‰¹é‡æµ‹é€Ÿå¤±è´¥ï¼š${err.message}`, "error", 6000);
          }
        });

        document.getElementById("config-table").addEventListener("click", async (event) => {
          const button = event.target.closest("button[data-action]");
          if (!button) return;
          const tr = button.closest("tr[data-id]");
          if (!tr) return;
          const id = tr.dataset.id;
          const action = button.dataset.action;
          try {
            if (action === "refresh-config") {
              await api.post(`/configs/${id}/refresh`);
              showStatus("é…ç½®åˆ·æ–°å®Œæˆ", "success");
              await Promise.all([loadConfigs(), loadNodes()]);
            } else if (action === "pull-nodes") {
              const nodes = await api.post(`/configs/${id}/pull-nodes`);
              renderNodes(nodes);
              showStatus(`è®¢é˜…èŠ‚ç‚¹å·²åŒæ­¥ï¼ˆ${nodes.length}ï¼‰`, "success");
              await Promise.all([loadConfigs(), loadNodes()]);
            } else if (action === "delete-config") {
              if (!confirm("ç¡®è®¤åˆ é™¤è¯¥é…ç½®ï¼Ÿ")) return;
              await api.delete(`/configs/${id}`);
              showStatus("é…ç½®å·²åˆ é™¤", "success");
              await Promise.all([loadConfigs(), loadNodes()]);
            }
          } catch (err) {
            showStatus(`æ“ä½œå¤±è´¥ï¼š${err.message}`, "error", 6000);
          }
        });

        if (systemProxySaveButton) {
          systemProxySaveButton.addEventListener("click", async () => {
            try {
              systemProxySaveButton.disabled = true;
              const payload = {
                enabled: Boolean(systemProxySettings && systemProxySettings.enabled),
                ignoreHosts: collectIgnoreHosts(),
              };
              const response = await api.put("/settings/system-proxy", payload);
              const data = response && response.settings ? response.settings : response;
              systemProxySettings = {
                enabled: Boolean(data.enabled),
                ignoreHosts: Array.isArray(data.ignoreHosts) ? data.ignoreHosts : [...SYSTEM_PROXY_DEFAULTS],
              };
              renderSystemProxy(systemProxySettings);
              updateXrayUI(xrayStatus);
              const msg = response && response.message ? response.message : "ç³»ç»Ÿä»£ç†è®¾ç½®å·²ä¿å­˜";
              showStatus(msg, response && response.message ? "info" : "success");
            } catch (err) {
              showStatus(`ä¿å­˜ç³»ç»Ÿä»£ç†å¤±è´¥ï¼š${err.message}`, "error", 6000);
            } finally {
              systemProxySaveButton.disabled = false;
            }
          });
        }

        if (systemProxyResetButton) {
          systemProxyResetButton.addEventListener("click", () => {
            systemProxySettings = {
              ...systemProxySettings,
              ignoreHosts: [...SYSTEM_PROXY_DEFAULTS],
            };
            renderSystemProxy(systemProxySettings);
            updateXrayUI(xrayStatus);
          });
        }

        renderSystemProxy(systemProxySettings);

        const componentTable = document.getElementById("component-table");
        if (componentTable) {
          componentTable.addEventListener("click", async (event) => {
            const button = event.target.closest("button[data-action]");
            if (!button) return;
            const tr = button.closest("tr[data-id]");
            if (!tr) return;
            const id = tr.dataset.id;
            const action = button.dataset.action;
            try {
              if (action === "delete-component") {
                if (!confirm("ç¡®è®¤åˆ é™¤è¯¥ç»„ä»¶ï¼Ÿ")) return;
                await api.delete(`/components/${id}`);
                showStatus("ç»„ä»¶å·²åˆ é™¤", "success");
                await loadComponents();
                await refreshXrayStatus();
              }
            } catch (err) {
              showStatus(`ç»„ä»¶æ“ä½œå¤±è´¥ï¼š${err.message}`, "error", 6000);
            }
          });
        }

        document.querySelectorAll(".ensure-component").forEach((button) => {
          button.addEventListener("click", async () => {
            const kind = button.dataset.kind;
            if (!kind) return;
            button.disabled = true;
            try {
              await ensureComponent(kind);
            } finally {
              button.disabled = false;
            }
          });
        });

        document.getElementById("profile-form").addEventListener("submit", async (event) => {
          event.preventDefault();
          const form = event.target;
          const payload = {
            defaultNodeId: form.defaultNodeId.value.trim(),
            dns: {
              strategy: form.dnsStrategy.value.trim(),
              servers: parseList(form.dnsServers.value),
            },
          };
          try {
            const updated = await api.put("/traffic/profile", payload);
            renderTrafficProfile(updated);
            showStatus("é»˜è®¤å‡ºå£ä¸ DNS å·²æ›´æ–°", "success");
          } catch (err) {
            showStatus(`æ›´æ–°å¤±è´¥ï¼š${err.message}`, "error", 6000);
          }
        });

        document.getElementById("rule-form").addEventListener("submit", async (event) => {
          event.preventDefault();
          const form = event.target;
          const payload = {
            name: form.name.value.trim(),
            targets: parseList(form.targets.value),
            nodeId: form.nodeId.value.trim(),
            priority: parseNumber(form.priority.value),
          };
          if (!payload.name || payload.targets.length === 0 || !payload.nodeId) {
            showStatus("è¯·å®Œæ•´å¡«å†™è§„åˆ™ä¿¡æ¯", "error");
            return;
          }
          try {
            await api.post("/traffic/rules", payload);
            form.reset();
            showStatus("è§„åˆ™æ·»åŠ æˆåŠŸ", "success");
            await loadTraffic();
          } catch (err) {
            showStatus(`æ·»åŠ è§„åˆ™å¤±è´¥ï¼š${err.message}`, "error", 6000);
          }
        });

        document.getElementById("rule-table").addEventListener("click", async (event) => {
          const button = event.target.closest("button[data-action]");
          if (!button) return;
          const tr = button.closest("tr[data-id]");
          if (!tr) return;
          const id = tr.dataset.id;
          const action = button.dataset.action;
          if (action !== "delete-rule") return;
          try {
            if (!confirm("ç¡®è®¤åˆ é™¤è¯¥åˆ†æµè§„åˆ™ï¼Ÿ")) return;
            await api.delete(`/traffic/rules/${id}`);
            showStatus("è§„åˆ™å·²åˆ é™¤", "success");
            await loadTraffic();
          } catch (err) {
            showStatus(`åˆ é™¤å¤±è´¥ï¼š${err.message}`, "error", 6000);
          }
        });

        // Initial load
        loadNodes();
        loaders[currentPanel]?.();
        ensureNodesPolling();
      })();

      // çª—å£æ§åˆ¶æŒ‰é’®äº‹ä»¶
      if (window.electronAPI) {
        document.getElementById('minimize-btn').addEventListener('click', () => {
          window.electronAPI.minimizeWindow();
        });

        document.getElementById('maximize-btn').addEventListener('click', () => {
          window.electronAPI.maximizeWindow();
        });

        document.getElementById('close-btn').addEventListener('click', () => {
          window.electronAPI.closeWindow();
        });
      }
      
      // Theme toggle
      const themeToggleBtn = document.getElementById("theme-toggle-btn");
      const themeStylesheet = document.getElementById("theme-stylesheet");
      let isDark = true;
      
      themeToggleBtn.addEventListener("click", () => {
        isDark = !isDark;
        const newTheme = isDark ? "theme-dark.css" : "theme-light.css";
        const icon = isDark ? "ğŸŒ™" : "â˜€ï¸";
        themeStylesheet.href = newTheme;
        themeToggleBtn.textContent = `${icon} åˆ‡æ¢ä¸»é¢˜`;
        localStorage.setItem("theme", isDark ? "dark" : "light");
      });
      
      // Load saved theme
      const savedTheme = localStorage.getItem("theme");
      if (savedTheme === "light") {
        themeToggleBtn.click();
      }
    </script>
    </div><!-- .app-container -->
  </body>
</html>
