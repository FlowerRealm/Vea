<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Vea Console</title>
  <style>
    @font-face {
      font-family: "FiraCode Nerd Font";
      src: url("fonts/FiraCodeNerdFont-Regular.ttf") format("truetype");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: "FiraCode Nerd Font";
      src: url("fonts/FiraCodeNerdFont-Medium.ttf") format("truetype");
      font-weight: 500;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: "FiraCode Nerd Font";
      src: url("fonts/FiraCodeNerdFont-SemiBold.ttf") format("truetype");
      font-weight: 600;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: "FiraCode Nerd Font";
      src: url("fonts/FiraCodeNerdFont-Bold.ttf") format("truetype");
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }

    :root {
      /* Premium Dark (Linear-esque) */
      --bg-root: #050505;
      --bg-sidebar: rgba(10, 10, 10, 0.8);
      --bg-card: rgba(255, 255, 255, 0.03);
      --bg-card-hover: rgba(255, 255, 255, 0.06);
      --bg-secondary: rgba(255, 255, 255, 0.05);

      --border-subtle: rgba(255, 255, 255, 0.08);
      --border-highlight: rgba(255, 255, 255, 0.15);

      --text-primary: #ededed;
      --text-secondary: #a1a1a1;
      --text-tertiary: #6e6e6e;

      --accent: #ffffff;
      --accent-glow: 0 0 20px rgba(255, 255, 255, 0.15);

      --success: #27c93f;
      --warning: #ffbd2e;
      --error: #ff5f56;

      --radius-sm: 6px;
      --radius-md: 12px;
      --radius-lg: 16px;

      --font-sans: "FiraCode Nerd Font", "FiraCode Nerd Font Mono", "Fira Code", "FiraCode", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      --font-mono: "FiraCode Nerd Font", "FiraCode Nerd Font Mono", "Fira Code", "FiraCode", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;

      --ease: cubic-bezier(0.23, 1, 0.32, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background-color: var(--bg-root);
      color: var(--text-primary);
      font-family: var(--font-sans);
      height: 100vh;
      display: grid;
      grid-template-columns: 240px 1fr;
      /* Restored wider sidebar for elegance */
      grid-template-rows: 44px 1fr;
      overflow: hidden;
      font-size: 14px;
      letter-spacing: -0.01em;
      -webkit-font-smoothing: antialiased;
    }

    /* === Titlebar === */
    .titlebar {
      grid-column: 1 / -1;
      grid-row: 1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      background: var(--bg-root);
      border-bottom: 1px solid var(--border-subtle);
      -webkit-app-region: drag;
      user-select: none;
      z-index: 50;
    }

    .titlebar-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .logo-dot {
      width: 8px;
      height: 8px;
      background: var(--text-primary);
      border-radius: 50%;
      box-shadow: var(--accent-glow);
    }

    .titlebar-controls {
      display: flex;
      gap: 8px;
      -webkit-app-region: no-drag;
    }

    .window-ctrl {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--border-subtle);
      cursor: pointer;
      transition: 0.2s;
    }

    .window-ctrl:hover {
      background: var(--text-secondary);
    }

    /* macOS-style window control colors */
    #close-btn {
      background: #ff5f57;
    }
    #minimize-btn {
      background: #febc2e;
    }
    #maximize-btn {
      background: #28c840;
    }
    #close-btn:hover {
      background: #ff7b74;
    }
    #minimize-btn:hover {
      background: #ffd06a;
    }
    #maximize-btn:hover {
      background: #4fe06a;
    }

    /* === Sidebar === */
    .sidebar {
      grid-column: 1;
      grid-row: 2;
      background: var(--bg-sidebar);
      border-right: 1px solid var(--border-subtle);
      display: flex;
      flex-direction: column;
      padding: 24px 16px;
      backdrop-filter: blur(20px);
    }

    .sidebar-section-title {
      font-size: 11px;
      text-transform: uppercase;
      color: var(--text-tertiary);
      margin-bottom: 12px;
      padding-left: 12px;
      font-weight: 600;
      letter-spacing: 0.05em;
    }

    .nav-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      border-radius: var(--radius-sm);
      color: var(--text-secondary);
      background: transparent;
      border: none;
      cursor: pointer;
      transition: all 0.3s var(--ease);
      font-size: 14px;
      font-weight: 500;
      text-align: left;
      margin-bottom: 4px;
    }

    .nav-item svg {
      width: 18px;
      height: 18px;
      opacity: 0.9;
      stroke-width: 2.5;
      transition: 0.3s;
    }

    .nav-item:hover {
      background: var(--bg-card-hover);
      color: var(--text-primary);
    }

    .nav-item:hover svg {
      opacity: 1;
    }

    .nav-item.active {
      background: var(--bg-card-hover);
      color: var(--text-primary);
    }

    .nav-item.active svg {
      opacity: 1;
      color: var(--accent);
    }

    /* === Main Content === */
    main {
      grid-column: 2;
      grid-row: 2;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      background: radial-gradient(circle at top right, #1a1a1a 0%, var(--bg-root) 40%);
    }

    /* === Status Toast === */
    .status-bar {
      position: absolute;
      bottom: 32px;
      right: 32px;
      padding: 12px 20px;
      background: #111;
      border: 1px solid var(--border-subtle);
      border-radius: 99px;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-primary);
      transform: translateY(100px);
      transition: transform 0.4s var(--ease);
      z-index: 900;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      gap: 10px;
      opacity: 0;
    }

    .status-bar::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .status-bar.visible {
      transform: translateY(0);
      opacity: 1;
    }

    .status-bar.success::before {
      background: var(--success);
      box-shadow: 0 0 10px var(--success);
    }

    .status-bar.error::before {
      background: var(--error);
      box-shadow: 0 0 10px var(--error);
    }

    .status-bar.info::before {
      background: var(--accent);
    }

    /* === Panels === */
    .panel {
      display: none;
      height: 100%;
      padding: 48px 64px;
      overflow-y: auto;
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
      animation: fadeUp 0.5s var(--ease);
    }

    .panel.active {
      display: flex;
      flex-direction: column;
    }

    /* Nodes panel: 固定头部 + 列表区滚动 */
    #panel-nodes {
      overflow: hidden;
    }

    #panel-nodes .nodes-table-card {
      padding: 0;
      flex: 1;
      min-height: 0;
      overflow: auto;
      background: transparent;
      border: none;
      box-shadow: none;
      border-radius: 0;
    }

    #panel-nodes .nodes-table-card:hover {
      transform: none;
      box-shadow: none;
    }

    #panel-nodes #nodes-table thead th {
      position: sticky;
      top: 0;
      background: var(--bg-card);
      z-index: 1;
    }

    #nodes-table {
      border-collapse: separate;
      border-spacing: 0;
    }

    #nodes-table thead {
      display: none;
    }

    #nodes-table td {
      border-bottom: none;
      padding: 0;
    }

    #nodes-table tr:hover td {
      background: transparent;
      color: inherit;
    }

    #nodes-table tbody tr.node-group-row td {
      background: transparent;
      color: var(--text-primary);
      font-weight: 700;
      font-size: 13px;
      letter-spacing: 0.02em;
      padding: 16px 0 6px;
      border-top: 3px solid var(--border-highlight);
      border-bottom: none;
    }

    #nodes-table tbody tr.node-group-row:first-child td {
      border-top: none;
    }

    #nodes-table tbody tr.node-group-row .node-group-label {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 6px 12px;
      border-radius: 12px;
      background: var(--bg-card);
    }

    #nodes-table tbody tr.node-group-row .node-group-pill {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--accent);
      color: var(--bg-root);
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.06em;
    }

    #nodes-table tbody tr.node-group-row .node-group-name {
      font-weight: 700;
    }

    #nodes-table tbody tr.node-group-row .node-group-count {
      margin-left: auto;
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border-highlight);
      background: var(--bg-card);
      color: var(--text-secondary);
      font-weight: 600;
    }

    #nodes-table tbody tr.node-card-row td {
      padding: 0;
    }

    #nodes-table tbody tr.node-card-row .node-card {
      background: transparent;
      border: none;
      border-radius: 0;
      border-top: 1px solid var(--border-subtle);
      padding: 14px 4px 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #nodes-table tbody tr.node-group-row + tr.node-card-row .node-card {
      border-top: none;
    }

    #nodes-table tbody tr.node-card-row .node-card-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    #nodes-table tbody tr.node-card-row .node-card-title {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    #nodes-table tbody tr.node-card-row .node-card-name {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 14px;
    }

    #nodes-table tbody tr.node-card-row .node-card-protocol {
      font-size: 11px;
      font-weight: 700;
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--bg-secondary);
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    #nodes-table tbody tr.node-card-row .node-card-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      color: var(--text-tertiary);
      font-size: 12px;
    }

    #nodes-table tbody tr.node-card-row .node-card-addr {
      color: var(--text-secondary);
      font-family: var(--font-mono);
      font-size: 12px;
    }

    #nodes-table tbody tr.node-card-row .node-card-id {
      color: var(--text-tertiary);
      font-family: var(--font-mono);
      font-size: 11px;
    }

    #nodes-table tbody tr.node-card-row .node-card-stats {
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    #nodes-table tbody tr.node-card-row .node-card-stat {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    #nodes-table tbody tr.node-card-row .node-card-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }


    /* Logs panel: 固定工具栏 + 内容区滚动 */
    #panel-logs {
      overflow: hidden;
    }

    #panel-logs .panel-header {
      margin-bottom: 24px;
    }

    #panel-logs .log-tabs {
      flex: 0 0 auto;
      margin-bottom: 16px;
    }

    #panel-logs .log-card {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .log-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .log-meta {
      color: var(--text-secondary);
      font-family: var(--font-mono);
      font-size: 12px;
    }

    .log-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .log-actions .log-autoscroll {
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
      padding-left: 10px;
      margin-left: 2px;
      border-left: 1px solid var(--border-subtle);
    }

    .log-actions .log-label {
      color: var(--text-secondary);
      font-size: 12px;
    }

    .log-container {
      flex: 1;
      min-height: 0;
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      padding: 12px;
      overflow: auto;
    }

    .log-container pre {
      margin: 0;
      font-family: var(--font-mono);
      font-size: 12px;
      line-height: 1.4;
      white-space: pre;
      color: var(--text-primary);
    }

    @keyframes fadeUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .panel-header {
      margin-bottom: 48px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
    }

    .panel-title h2 {
      font-size: 32px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 8px;
      letter-spacing: -0.02em;
    }

    .panel-title p {
      color: var(--text-secondary);
      font-size: 15px;
      max-width: 500px;
      line-height: 1.5;
    }

    /* === Cards === */
    .card {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      padding: 24px;
      transition: all 0.3s var(--ease);
      position: relative;
      overflow: hidden;
    }

    .text-truncate {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 200px;
      display: inline-block;
      vertical-align: bottom;
    }

    .card:hover {
      border-color: var(--border-highlight);
      transform: translateY(-2px);
      background: var(--bg-card-hover);
      box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.3);
    }

    /* === Dashboard Hero === */
    .dashboard-hero {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px 0 80px;
      position: relative;
    }

    .status-ring-container {
      position: relative;
      width: 140px;
      height: 140px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 32px;
    }

    .status-ring-bg {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 1px solid var(--border-subtle);
      background: radial-gradient(circle, rgba(255, 255, 255, 0.02) 0%, transparent 70%);
    }

    #proxy-toggle {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: var(--text-primary);
      color: var(--bg-root);
      border: none;
      font-size: 32px;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.1);
    }

    #proxy-toggle:hover {
      transform: scale(1.05);
      box-shadow: 0 0 0 8px rgba(255, 255, 255, 0.1);
    }

    #proxy-toggle:active {
      transform: scale(0.95);
    }

    #proxy-toggle.active {
      background: var(--success);
      color: #fff;
      box-shadow: 0 0 0 8px rgba(39, 201, 63, 0.2), 0 0 30px rgba(39, 201, 63, 0.4);
    }

    .hero-status-text {
      text-align: center;
    }

    #proxy-status {
      font-size: 28px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 8px;
      letter-spacing: -0.03em;
    }

    #proxy-status-desc {
      font-size: 15px;
      color: var(--text-tertiary);
    }

    .route-selector {
      margin-top: 12px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .route-selector select {
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      padding: 6px 10px;
    }

    /* === Metrics Grid === */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 24px;
      max-width: 900px;
      margin: 0 auto;
      width: 100%;
    }

    .metric-card {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: 0.2s;
      backdrop-filter: blur(10px);
    }

    .metric-card:hover {
      border-color: var(--border-highlight);
      transform: translateY(-2px);
      background: var(--bg-card-hover);
      box-shadow: 0 10px 30px -10px rgba(0, 0, 0, 0.5);
    }

    .metric-label {
      font-size: 12px;
      color: var(--text-tertiary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .metric-value {
      font-size: 24px;
      font-weight: 500;
      color: var(--text-primary);
      font-family: var(--font-mono);
    }

    /* === Node Info === */
    .info-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 0;
      border-bottom: 1px solid var(--border-subtle);
    }

    .info-row:last-child {
      border-bottom: none;
    }

    .info-label {
      color: var(--text-secondary);
      font-size: 13px;
    }

    .info-value {
      color: var(--text-primary);
      font-family: var(--font-mono);
      font-size: 13px;
    }

    /* === Node List === */
    .node-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding-bottom: 24px;
    }

    .node-row {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 12px 16px;
      transition: all 0.2s ease;
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      align-items: center;
      gap: 16px;
      cursor: pointer;
      backdrop-filter: blur(10px);
    }

    .node-row:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.15);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

	    .node-row.active {
	      background: rgba(255, 255, 255, 0.08);
	      border-color: rgba(255, 255, 255, 0.35);
	      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.22), 0 8px 32px rgba(0, 0, 0, 0.4);
	    }

    .node-row-main {
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 0;
    }

    .node-row-title {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .node-row-name {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      line-height: 1.4;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .node-row-meta {
      font-size: 12px;
      color: var(--text-tertiary);
      font-family: var(--font-mono);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .node-row-protocol {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-secondary);
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
    }

    .node-row-metrics {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .node-metric {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: color 0.2s;
    }

    .node-metric:hover {
      color: var(--text-primary);
    }

    .node-metric svg {
      opacity: 0.6;
    }

    .node-metric-value {
      font-family: var(--font-mono);
      font-weight: 500;
    }

    .node-metric-value.good {
      color: #4ade80;
    }

    .node-metric-value.fair {
      color: #fbbf24;
    }

    .node-metric-value.poor {
      color: #f87171;
    }


    /* === Buttons & Inputs === */
    button {
      font-size: 13px;
      padding: 8px 16px;
      background: transparent;
      border: 1px solid var(--border-subtle);
      color: var(--text-primary);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: var(--ease);
    }

    button:hover {
      background: var(--bg-card-hover);
      border-color: var(--text-secondary);
    }

    button.primary {
      background: var(--text-primary);
      color: #000;
      border-color: var(--text-primary);
      font-weight: 600;
    }

	    button.primary:hover {
	      background: #fff;
	      box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
	      transform: translateY(-1px);
	    }

	    .mini-btn {
	      padding: 6px 10px;
	      font-size: 12px;
	    }

	    .mini-select {
	      width: auto;
	      padding: 6px 10px;
	      font-size: 12px;
	    }

	    input,
	    select,
	    textarea {
	      background: rgba(0, 0, 0, 0.2);
      border: 1px solid var(--border-subtle);
      color: var(--text-primary);
      padding: 12px 16px;
      font-size: 14px;
      width: 100%;
      border-radius: var(--radius-sm);
      outline: none;
      transition: var(--ease);
      font-family: var(--font-mono);
    }

    input:focus,
    select:focus,
    textarea:focus {
      border-color: var(--text-secondary);
      background: rgba(0, 0, 0, 0.4);
    }

    /* === Tables === */
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    th {
      text-align: left;
      color: var(--text-tertiary);
      font-weight: 500;
      padding: 16px;
      border-bottom: 1px solid var(--border-subtle);
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 0.05em;
    }

    td {
      padding: 16px;
      border-bottom: 1px solid var(--border-subtle);
      color: var(--text-secondary);
    }

    tr:hover td {
      background: var(--bg-card-hover);
      color: var(--text-primary);
    }

    /* === Modal === */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      z-index: 200;
      align-items: center;
      justify-content: center;
    }

    .modal.open {
      display: flex;
    }

    .modal-content {
      background: #0f0f0f;
      border: 1px solid var(--border-subtle);
      padding: 40px;
      width: 520px;
      border-radius: var(--radius-lg);
      box-shadow: 0 40px 80px rgba(0, 0, 0, 0.5);
      position: relative;
    }

    .modal-backdrop {
      position: absolute;
      inset: 0;
      z-index: -1;
    }

    /* === Toggle Switch === */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 22px;
      cursor: pointer;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      transition: var(--ease);
      border-radius: 22px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: var(--text-tertiary);
      transition: var(--ease);
      border-radius: 50%;
    }

    .toggle-switch input:checked+.toggle-slider {
      background-color: var(--success);
      border-color: var(--success);
    }

    .toggle-switch input:checked+.toggle-slider:before {
      background-color: white;
      transform: translateX(18px);
    }

    .toggle-switch input:disabled+.toggle-slider {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* === Switch (Alias for toggle-switch) === */
    .switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 22px;
      cursor: pointer;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      transition: var(--ease);
      border-radius: 22px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: var(--text-tertiary);
      transition: var(--ease);
      border-radius: 50%;
    }

    .switch input:checked+.slider {
      background-color: var(--success);
      border-color: var(--success);
    }

    .switch input:checked+.slider:before {
      background-color: white;
      transform: translateX(18px);
    }

    .switch input:disabled+.slider {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* === Progress Bar === */
    .install-progress {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: var(--bg-secondary);
      border-radius: 3px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--success), #4ade80);
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    .progress-text {
      font-size: 11px;
      color: var(--text-secondary);
    }

    /* === Icons === */
    .icon {
      display: inline-block;
      width: 1em;
      height: 1em;
      stroke-width: 2;
      stroke: currentColor;
      fill: none;
    }

    /* === Toolbar === */
    .node-toolbar {
      display: flex;
      gap: 12px;
      margin-bottom: 32px;
      align-items: center;
    }

    .node-tabs {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 4px;
      flex: 1;
    }

    .node-tab {
      padding: 6px 16px;
      border-radius: 99px;
      font-size: 12px;
      white-space: nowrap;
      cursor: pointer;
      color: var(--text-secondary);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid transparent;
      transition: 0.2s;
    }

    .node-tab:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }

    .node-tab.active {
      background: var(--text-primary);
      color: #000;
      font-weight: 600;
    }

    .add-node-button {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--text-primary);
      color: #000;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: none;
      transition: 0.2s;
    }

    .add-node-button:hover {
      transform: scale(1.1);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
    }

    /* Form Grid */
    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
    }

    .form-grid label {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .form-actions {
      grid-column: 1 / -1;
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      margin-top: 16px;
    }

    /* Settings Navigation */
    .settings-nav-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 16px;
      background: transparent;
      border: none;
      border-radius: var(--radius-md);
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: left;
    }

    .settings-nav-item:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .settings-nav-item.active {
      background: var(--accent);
      color: var(--bg-root);
    }

    .settings-nav-item svg {
      flex-shrink: 0;
      opacity: 0.9;
      stroke-width: 2.5;
    }

    .settings-nav-item:hover svg {
      opacity: 1;
    }

    .settings-nav-item.active svg {
      opacity: 1;
    }

    .settings-content {
      display: none;
    }

    .settings-content.active {
      display: block;
    }

    /* Core tab styles */
    .core-tab.active {
      border-bottom-color: var(--primary) !important;
      color: var(--text-primary) !important;
    }

    .core-content {
      display: none;
    }

    .core-content.active {
      display: block;
    }

    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    ::-webkit-scrollbar-thumb:active {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Firefox */
    * {
      scrollbar-width: thin;
      scrollbar-color: rgba(255, 255, 255, 0.1) transparent;
    }

    /* ===== Chain List Editor ===== */
    .chain-list-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      padding: 24px 32px;
      max-width: 900px;
      margin: 0 auto;
    }

    .chain-list-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 24px;
      gap: 24px;
    }

    .chain-list-title h3 {
      font-size: 22px;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0 0 4px 0;
    }

    .chain-list-title p {
      font-size: 13px;
      color: var(--text-secondary);
      margin: 0;
    }

    .chain-list-actions {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .chain-list-actions .route-selector {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .chain-list-actions .route-selector select {
      padding: 6px 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-sm);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      font-size: 13px;
    }

    /* 规则列表 */
    .chain-rules-list {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding-bottom: 16px;
    }

    .chain-rules-empty {
      text-align: center;
      padding: 48px 24px;
      color: var(--text-tertiary);
      font-size: 14px;
    }

    /* 规则项 */
    .chain-rule-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: var(--radius-md);
      transition: border-color 0.2s, box-shadow 0.2s, opacity 0.2s;
      backdrop-filter: blur(10px);
    }

    .chain-rule-item:hover {
      border-color: rgba(255, 255, 255, 0.15);
    }

    .chain-rule-item.dragging {
      opacity: 0.5;
      border-color: var(--accent);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    }

    .chain-rule-item.drag-over {
      border-color: var(--accent);
      background: rgba(59, 130, 246, 0.1);
    }

    .chain-rule-item.disabled {
      opacity: 0.5;
    }

    .chain-rule-drag {
      cursor: grab;
      color: var(--text-tertiary);
      font-size: 16px;
      padding: 4px;
      user-select: none;
    }

    .chain-rule-drag:active {
      cursor: grabbing;
    }

    .chain-rule-main {
      flex: 1;
      min-width: 0;
    }

    .chain-rule-target {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 2px;
    }

    .chain-rule-target.direct { color: #4ade80; }
    .chain-rule-target.block { color: #f87171; }

    .chain-rule-info {
      font-size: 12px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .chain-rule-meta {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .chain-rule-actions {
      display: flex;
      gap: 4px;
    }

    .chain-rule-actions button {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-size: 14px;
      transition: background 0.15s, color 0.15s;
    }

    .chain-rule-actions button:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }

    .chain-rule-actions button.delete:hover {
      color: #f87171;
    }

    /* 工具栏 */
    .chain-list-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 0;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      margin-top: 8px;
    }

    .chain-list-toolbar .toolbar-status {
      font-size: 12px;
      color: var(--text-tertiary);
    }

    .chain-list-toolbar .toolbar-status.dirty {
      color: #fbbf24;
    }

    .toolbar-actions {
      display: flex;
      gap: 8px;
    }

    /* 按钮样式 */
    .chain-btn {
      padding: 8px 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-sm);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      font-size: 13px;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }

    .chain-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .chain-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: var(--bg-root);
    }

    .chain-btn.primary:hover {
      background: var(--accent-hover, #2563eb);
      border-color: var(--accent-hover, #2563eb);
      color: white;
    }

    .chain-btn.danger {
      background: transparent;
      border-color: #f87171;
      color: #f87171;
    }

    .chain-btn.danger:hover {
      background: #f87171;
      color: white;
    }

    /* 规则编辑弹窗 */
    .chain-rule-dialog {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .chain-rule-dialog.open {
      display: flex;
    }

    .chain-rule-dialog-content {
      background: var(--bg-card);
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
      width: 90%;
      max-width: 500px;
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .chain-rule-dialog-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .chain-rule-dialog-header h4 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .chain-rule-dialog-close {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      font-size: 20px;
      cursor: pointer;
      border-radius: var(--radius-sm);
    }

    .chain-rule-dialog-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }

    .chain-rule-dialog-body {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .chain-form-group {
      margin-bottom: 16px;
    }

    .chain-form-group label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 6px;
    }

    .chain-form-group input,
    .chain-form-group select,
    .chain-form-group textarea {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-sm);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      font-size: 13px;
      box-sizing: border-box;
    }

    .chain-form-group textarea {
      resize: vertical;
      font-family: var(--font-mono);
      font-size: 12px;
    }

    .rule-chain-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .rule-chain-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .rule-chain-item select {
      flex: 1;
    }

    .rule-chain-item button {
      width: 28px;
      height: 28px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-secondary);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: background 0.15s, color 0.15s, border-color 0.15s;
    }

    .rule-chain-item button:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      color: var(--text-primary);
    }

    .rule-chain-item button.danger {
      background: transparent;
      border-color: #f87171;
      color: #f87171;
    }

    .rule-chain-item button.danger:hover {
      background: #f87171;
      color: white;
    }

    .rule-chain-hint {
      margin-top: 6px;
      font-size: 12px;
      color: var(--text-tertiary);
      line-height: 1.4;
    }

    .chain-route-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }

    .chain-section-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 12px;
    }

    .rule-template-picker {
      display: flex;
      gap: 8px;
    }

    .rule-template-picker select {
      flex: 1;
    }

    .chain-rule-dialog-footer {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 16px 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }

    /* Toggle switch */
    .chain-toggle {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 22px;
    }

    .chain-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .chain-toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 22px;
      transition: 0.2s;
    }

    .chain-toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 3px;
      bottom: 3px;
      background: white;
      border-radius: 50%;
      transition: 0.2s;
    }

    .chain-toggle input:checked + .chain-toggle-slider {
      background: var(--accent);
    }

    .chain-toggle input:checked + .chain-toggle-slider:before {
      background: var(--bg-root);
      transform: translateX(18px);
    }
  </style>
</head>

<body>
  <!-- Titlebar -->
  <div class="titlebar">
    <div class="titlebar-title">
      <div class="logo-dot"></div>
      Vea
    </div>
    <div class="titlebar-controls">
      <div class="window-ctrl" id="minimize-btn"></div>
      <div class="window-ctrl" id="maximize-btn"></div>
      <div class="window-ctrl close" id="close-btn"></div>
    </div>
  </div>

  <!-- Sidebar -->
  <aside class="sidebar" id="menu">
    <div class="sidebar-section-title">主要</div>
    <button class="nav-item active" data-target="panel-home">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="7" height="7"></rect>
        <rect x="14" y="3" width="7" height="7"></rect>
        <rect x="14" y="14" width="7" height="7"></rect>
        <rect x="3" y="14" width="7" height="7"></rect>
      </svg>
      控制台
    </button>
    <button class="nav-item" data-target="panel1">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
        <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"></path>
      </svg>
	      FRouter
	    </button>
	    <button class="nav-item" data-target="panel2">
	      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
	        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
	        <polyline points="14 2 14 8 20 8"></polyline>
	        <line x1="16" y1="13" x2="8" y2="13"></line>
	        <line x1="16" y1="17" x2="8" y2="17"></line>
	        <polyline points="10 9 9 9 8 9"></polyline>
	      </svg>
	      订阅
	    </button>
	    <button class="nav-item" data-target="panel-nodes">
	      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
	        <circle cx="12" cy="12" r="3"></circle>
	        <path d="M12 5v4"></path>
	        <path d="M12 15v4"></path>
	        <path d="M5 12h4"></path>
	        <path d="M15 12h4"></path>
	      </svg>
	      节点
	    </button>

	    <div class="sidebar-section-title" style="margin-top: 24px;">系统</div>
	    <button class="nav-item" data-target="panel3">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
        <path
          d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z">
        </path>
        <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
        <line x1="12" y1="22.08" x2="12" y2="12"></line>
      </svg>
	      组件
	    </button>

	    <button class="nav-item" data-target="panel-logs">
	      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
	        <polyline points="4 17 10 11 4 5"></polyline>
	        <line x1="12" y1="19" x2="20" y2="19"></line>
	      </svg>
	      日志
	    </button>

	    <button class="nav-item" data-target="panel-settings">
	      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
	        <circle cx="12" cy="12" r="3"></circle>
        <path
          d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
        </path>
      </svg>
      设置
    </button>
  </aside>

  <!-- Main Content -->
  <main>
    <div id="status" class="status-bar"></div>

    <!-- Dashboard -->
    <section id="panel-home" class="panel active">
      <div class="dashboard-hero">
        <div class="status-ring-container">
          <div class="status-ring-bg"></div>
          <button id="proxy-toggle" data-mode="">
            <svg viewBox="0 0 24 24" width="32" height="32" stroke="currentColor" stroke-width="2.5" fill="none"
              stroke-linecap="round" stroke-linejoin="round">
              <path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path>
              <line x1="12" y1="2" x2="12" y2="12"></line>
            </svg>
          </button>
        </div>
      </div>

      <div class="metrics-grid">
        <div class="metric-card">
          <div class="metric-label">
            <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2" fill="none">
              <path d="M22 12h-4l-3 9L9 3l-3 9H2"></path>
            </svg>
            延迟
          </div>
          <div class="metric-value" id="home-node-latency">--</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">
            <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2" fill="none">
              <polyline points="17 1 21 5 17 9"></polyline>
              <path d="M3 11V9a4 4 0 0 1 4-4h14"></path>
              <polyline points="7 23 3 19 7 15"></polyline>
              <path d="M21 13v2a4 4 0 0 1-4 4H3"></path>
            </svg>
            速度
          </div>
          <div class="metric-value" id="home-node-speed">--</div>
        </div>
	        <div class="metric-card" id="tun-status-card">
	          <div class="metric-label">
	            <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2" fill="none">
	              <rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect>
	              <path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>
	            </svg>
	            TUN 模式
	          </div>
	          <div style="display:flex; align-items:center; gap:12px;">
	            <div class="metric-value" id="tun-status-value" style="cursor:pointer;" title="点击查看详情">--</div>
	            <label class="toggle-switch" title="启用/禁用 TUN 模式">
	              <input type="checkbox" id="tun-toggle">
	              <span class="toggle-slider"></span>
	            </label>
	          </div>
	          <div id="tun-permission-hint" style="display:none; margin-top:8px; font-size:11px; color:var(--warning); line-height:1.4;"></div>
	        </div>
	        <div class="metric-card" id="engine-select-card">
	          <div class="metric-label">
	            <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2" fill="none">
	              <rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect>
	              <rect x="9" y="9" width="6" height="6"></rect>
	            </svg>
	            内核偏好
	          </div>
	          <select id="engine-select" title="选择内核偏好（需要时会重启内核）">
	            <option value="auto" data-label="自动">自动</option>
	            <option value="singbox" data-label="sing-box">sing-box</option>
	            <option value="clash" data-label="Clash">Clash</option>
	          </select>
	        </div>
	        <div class="metric-card" id="ip-geo-card" style="grid-column: span 2;">
	          <div class="metric-label">
	            <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2" fill="none">
	              <circle cx="12" cy="12" r="10"></circle>
	              <line x1="2" y1="12" x2="22" y2="12"></line>
              <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z">
              </path>
            </svg>
            当前 IP
          </div>
          <div style="display:flex; align-items:center; gap:16px; flex-wrap:wrap;">
            <div class="metric-value" id="ip-geo-ip" style="font-family:var(--font-mono); font-size:15px;">--</div>
            <div id="ip-geo-location" style="font-size:12px; color:var(--text-secondary);">--</div>
            <button id="ip-geo-refresh"
              style="padding:4px 8px; font-size:11px; background:var(--bg-secondary); border:1px solid var(--border-subtle); border-radius:4px; color:var(--text-secondary); cursor:pointer;">
              <svg viewBox="0 0 24 24" width="12" height="12" stroke="currentColor" stroke-width="2" fill="none"
                style="vertical-align:middle;">
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
              </svg>
            </button>
          </div>
        </div>
      </div>
    </section>

    <!-- Chain Editor (Route Rules List) -->
    <section id="panel-chain" class="panel">
      <div class="chain-list-container">
        <!-- 头部 -->
        <div class="chain-list-header">
          <div class="chain-list-title">
            <h3>路由规则</h3>
            <p>拖拽调整优先级，位置越靠前优先级越高</p>
          </div>
          <div class="chain-list-actions">
            <div class="route-selector">
              <span>当前 FRouter</span>
              <select id="chain-route-select"></select>
            </div>
            <button id="chain-add-rule" class="chain-btn primary">+ 添加规则</button>
          </div>
        </div>

        <!-- 可排序规则列表 -->
        <div id="chain-rules-list" class="chain-rules-list">
          <div class="chain-rules-empty">暂无路由规则，点击"添加规则"创建</div>
        </div>

        <!-- 工具栏 -->
        <div class="chain-list-toolbar">
          <span class="toolbar-status" id="chain-status">已保存</span>
          <div class="toolbar-actions">
            <button class="chain-btn" id="chain-back">返回</button>
            <button class="chain-btn" id="chain-reset">重置</button>
            <button class="chain-btn primary" id="chain-save">保存</button>
          </div>
        </div>
      </div>

      <!-- 规则编辑弹窗 -->
      <div class="chain-rule-dialog" id="rule-edit-dialog">
        <div class="chain-rule-dialog-content">
          <div class="chain-rule-dialog-header">
            <h4 id="rule-dialog-title">编辑规则</h4>
            <button class="chain-rule-dialog-close" id="rule-dialog-close">&times;</button>
          </div>

          <div class="chain-rule-dialog-body">
            <div class="chain-form-group">
              <label>规则类型</label>
              <select id="rule-type">
                <option value="">无条件（默认路径）</option>
                <option value="route">路由规则</option>
              </select>
            </div>

            <!-- 路由规则区域 -->
            <div id="rule-route-section" class="chain-route-section" style="display:none;">
              <div class="chain-section-title">路由规则</div>

              <!-- 模板选择器 -->
              <div class="chain-form-group">
                <label>快速应用模板</label>
                <div class="rule-template-picker">
                  <select id="rule-template-category">
                    <option value="all">全部分类</option>
                  </select>
                  <select id="rule-template-select">
                    <option value="">选择模板...</option>
                  </select>
                </div>
              </div>

              <div class="chain-form-group">
                <label>匹配域名</label>
                <textarea id="rule-domains" rows="5" placeholder="每行一个，支持 geosite:cn、domain:example.com 等格式"></textarea>
              </div>
              <div class="chain-form-group">
                <label>匹配 IP</label>
                <textarea id="rule-ips" rows="5" placeholder="每行一个，支持 geoip:cn、192.168.0.0/16 等格式"></textarea>
              </div>
            </div>

            <div class="chain-form-group">
              <label>匹配后去向</label>
              <select id="rule-to">
                <option value="direct">不代理（直连）</option>
                <option value="block">阻断</option>
              </select>
            </div>

            <div class="chain-form-group" id="rule-chain-group" style="display:none;">
              <label>链式代理（后续节点）</label>
              <div id="rule-chain-list" class="rule-chain-list"></div>
              <button class="chain-btn" id="rule-chain-add" type="button">+ 添加节点</button>
              <div class="rule-chain-hint">第一跳在“匹配后去向”里选择，这里从第 2 跳开始添加。</div>
            </div>

            <div class="chain-form-group">
              <label>启用</label>
              <label class="chain-toggle">
                <input type="checkbox" id="rule-enabled" checked>
                <span class="chain-toggle-slider"></span>
              </label>
            </div>

            <div class="chain-form-group">
              <label>描述</label>
              <input type="text" id="rule-description" placeholder="可选：规则描述">
            </div>
          </div>

          <div class="chain-rule-dialog-footer">
            <button class="chain-btn danger" id="rule-delete" style="display:none;">删除</button>
            <div style="flex:1;"></div>
            <button class="chain-btn" id="rule-cancel">取消</button>
            <button class="chain-btn primary" id="rule-save">保存</button>
          </div>
        </div>
      </div>
    </section>

	    <!-- FRouters -->
	    <section id="panel1" class="panel">
	      <div class="panel-header">
	        <div class="panel-title">
	          <h2>FRouter</h2>
	          <p>管理和监控你的 FRouter 配置。</p>
	        </div>
	        <div class="panel-actions">
          <span id="core-state" style="font-size:12px; color:var(--text-secondary); margin-right:16px;">核心：
            未知</span>
	          <button id="node-refresh">刷新 FRouter</button>
	        </div>
	      </div>

      <div class="node-toolbar">
        <div id="node-tabs" class="node-tabs"></div>
        <button id="node-bulk-ping">全部测延迟</button>
        <button id="node-bulk-speed">全部测速</button>
        <button class="add-node-button" id="node-add-button">+</button>
      </div>
	      <div id="node-grid" class="node-grid">
	        <div class="card" style="text-align:center; color:var(--text-secondary);">暂无 FRouter</div>
	      </div>
	    </section>

    <!-- Configs -->
	    <section id="panel2" class="panel">
	      <div class="panel-header">
	        <div class="panel-title">
	          <h2>订阅</h2>
	          <p>管理订阅源和更新间隔。</p>
	        </div>
	        <div class="panel-actions">
	          <button id="config-add-button" class="primary">添加订阅源</button>
	          <button id="config-refresh">同步</button>
	        </div>
	      </div>
	      <div class="card" style="padding:0;">
	        <table id="config-table">
	          <thead>
	            <tr>
	              <th>名称</th>
	              <th>格式</th>
	              <th>更新间隔</th>
	              <th>最后同步</th>
	              <th>状态</th>
	              <th style="text-align:right">操作</th>
	            </tr>
	          </thead>
	          <tbody></tbody>
	        </table>
	      </div>
	    </section>

	    <!-- Nodes -->
	    <section id="panel-nodes" class="panel">
	      <div class="panel-header">
	        <div class="panel-title">
	          <h2>节点</h2>
	          <p>查看与测量全局节点（独立于 FRouter）。</p>
	        </div>
        <div class="panel-actions">
          <button id="nodes-bulk-ping">全部测延迟</button>
          <button id="nodes-bulk-speed">全部测速</button>
          <button id="nodes-add-button" class="primary">添加节点</button>
        </div>
      </div>
	      <div class="card nodes-table-card">
	        <table id="nodes-table">
	          <thead>
	            <tr>
	              <th>名称</th>
	              <th>协议</th>
	              <th>地址</th>
	              <th>延迟</th>
	              <th>速度</th>
	              <th style="text-align:right">操作</th>
	            </tr>
	          </thead>
	          <tbody>
	            <tr>
	              <td colspan="6" style="text-align:center; color:var(--text-secondary); padding:24px;">暂无节点</td>
	            </tr>
	          </tbody>
	        </table>
	      </div>
	    </section>

	    <!-- Components -->
	    <section id="panel3" class="panel">
	      <div class="panel-header">
	        <div class="panel-title">
	          <h2>组件</h2>
          <p>核心系统依赖和版本。</p>
        </div>
        <div class="panel-actions">
          <button id="component-refresh">刷新</button>
        </div>
      </div>
      <div class="card" style="padding:0;">
        <table id="component-table">
          <thead>
            <tr>
              <th>名称</th>
              <th>类型</th>
              <th>版本</th>
              <th>路径</th>
              <th>日期</th>
              <th>状态</th>
              <th style="text-align:right">操作</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- Logs -->
	    <section id="panel-logs" class="panel">
		      <div class="panel-header">
		        <div class="panel-title">
		          <h2>日志</h2>
		          <p>内核（sing-box / Clash）与应用（后端）运行日志（独立于终端输出）。</p>
		        </div>
		      </div>

	      <div class="node-tabs log-tabs" id="log-tabs">
	        <div class="node-tab active" data-log-tab="kernel">系统日志</div>
	        <div class="node-tab" data-log-tab="app">应用日志</div>
	      </div>

	      <div class="card log-card" id="kernel-log-card">
	        <div class="log-toolbar">
	          <div class="log-meta" id="kernel-log-meta">-</div>
	          <div class="log-actions">
	            <button class="mini-btn" id="kernel-log-refresh">刷新</button>
            <button class="mini-btn" id="kernel-log-copy">复制</button>
            <div class="log-autoscroll">
              <span class="log-label">自动滚动</span>
              <label class="chain-toggle">
                <input type="checkbox" id="kernel-log-autoscroll" checked>
                <span class="chain-toggle-slider"></span>
              </label>
            </div>
          </div>
        </div>
	        <div class="log-container" id="kernel-log-container">
	          <pre id="kernel-log-content"></pre>
	        </div>
	      </div>

	      <div class="card log-card" id="app-log-card" style="display:none;">
	        <div class="log-toolbar">
	          <div class="log-meta" id="app-log-meta">-</div>
	          <div class="log-actions">
	            <button class="mini-btn" id="app-log-refresh">刷新</button>
            <button class="mini-btn" id="app-log-copy">复制</button>
            <div class="log-autoscroll">
              <span class="log-label">自动滚动</span>
              <label class="chain-toggle">
                <input type="checkbox" id="app-log-autoscroll" checked>
                <span class="chain-toggle-slider"></span>
              </label>
            </div>
          </div>
        </div>
        <div class="log-container" id="app-log-container">
          <pre id="app-log-content"></pre>
        </div>
	      </div>
	    </section>

    <!-- Settings -->
    <section id="panel-settings" class="panel">
      <div class="panel-header">
        <div class="panel-title">
          <h2>设置</h2>
          <p>应用偏好与配置。</p>
        </div>
        <div class="panel-actions">
          <button id="settings-import-btn">导入设置</button>
          <button id="settings-export-btn">导出设置</button>
          <button id="settings-reset-btn">恢复默认</button>
        </div>
      </div>

      <div style="display:flex; gap:24px;">
        <!-- 左侧导航 -->
        <div class="settings-nav" style="flex:0 0 200px; display:flex; flex-direction:column; gap:4px;">
          <button class="settings-nav-item active" data-settings-tab="general">
            <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" fill="none" stroke-linecap="round"
              stroke-linejoin="round">
              <circle cx="12" cy="12" r="3"></circle>
              <path d="M12 1v6m0 6v6m9-9h-6m-6 0H3m15.4 6.4l-4.2-4.2m-6 0L3.6 7.6m12.8 12.8l-4.2-4.2m-6 0l-4.6 4.6">
              </path>
            </svg>
            外观
          </button>
          <button class="settings-nav-item" data-settings-tab="proxy">
            <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" fill="none" stroke-linecap="round"
              stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="2" y1="12" x2="22" y2="12"></line>
              <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z">
              </path>
            </svg>
            系统代理
          </button>
          <button class="settings-nav-item" data-settings-tab="network">
            <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" fill="none" stroke-linecap="round"
              stroke-linejoin="round">
              <rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect>
              <path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>
            </svg>
            TUN
          </button>
          <button class="settings-nav-item" data-settings-tab="singbox">
            <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" fill="none" stroke-linecap="round"
              stroke-linejoin="round">
              <path
                d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z">
              </path>
            </svg>
            sing-box
          </button>
          <button class="settings-nav-item" data-settings-tab="advanced">
            <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" fill="none" stroke-linecap="round"
              stroke-linejoin="round">
              <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
              <path d="M2 17l10 5 10-5M2 12l10 5 10-5"></path>
            </svg>
            高级
          </button>
        </div>

        <!-- 右侧内容区 -->
        <div style="flex:1; min-width:0;">
          <!-- 外观设置 -->
          <div class="settings-content active" id="settings-general"></div>

          <!-- 系统代理设置 -->
          <div class="settings-content" id="settings-proxy" style="display:none;"></div>

          <!-- TUN 设置 -->
          <div class="settings-content" id="settings-network" style="display:none;"></div>

          <!-- sing-box 设置 -->
          <div class="settings-content" id="settings-singbox" style="display:none;"></div>

          <!-- 高级设置 -->
          <div class="settings-content" id="settings-advanced" style="display:none;"></div>
        </div>
      </div>
    </section>
  </main>

  <div id="node-modal" class="modal">
    <div class="modal-backdrop"></div>
    <div class="modal-content"
      style="max-width: 900px; max-height: 90vh; overflow-y: auto; transform: scale(0.95); transform-origin: center;">
      <button id="node-modal-close" class="modal-close"
        style="position:absolute; top:24px; right:24px; background:none; border:none; color:var(--text-secondary); font-size:20px; cursor:pointer;">×</button>
      <form id="node-form" class="form-grid">
        <h3 style="grid-column:1/-1; margin-bottom:16px; font-size:18px; font-weight:600; color:var(--text-primary);">
          添加 FRouter</h3>

        <div
          style="grid-column:1/-1; padding:12px 14px; background:var(--bg-secondary); border-radius:8px; font-size:12px; color:var(--text-secondary); line-height:1.6;">
          这里只创建一个空的 FRouter（含 1 个配置槽）。节点/订阅请在「订阅」面板里拉取或更新。
        </div>

        <!-- Basic Settings -->
        <div
          style="display:none; grid-column:1/-1; font-weight:600; font-size:14px; color:var(--text-primary); margin-top:12px; padding-bottom:8px; border-bottom:1px solid var(--border-color);">
          入口配置</div>
        <label style="grid-column:1/-1;"><span>FRouter 名称 *</span><input name="name" type="text"
            placeholder="例如: 香港线路01" required></label>
        <div style="display:none">
          <label><span>入口地址 *</span><input name="address" type="text" placeholder="example.com 或 IP"></label>
          <label><span>入口端口 *</span><input name="port" type="number" placeholder="443"></label>
          <label>
            <span>协议 *</span>
            <select name="protocol" id="protocol-select">
              <option value="">选择协议</option>
              <option value="shadowsocks">Shadowsocks</option>
              <option value="vmess">VMess</option>
              <option value="vless">VLESS</option>
              <option value="trojan">Trojan</option>
              <option value="http">HTTP</option>
              <option value="socks5">SOCKS5</option>
            </select>
          </label>

          <!-- Shadowsocks Specific -->
          <div id="ss-fields"
            style="display:none; grid-column:1/-1; display:grid; grid-template-columns:1fr 1fr; gap:16px;">
            <label>
              <span>加密方式</span>
              <select name="ss_method">
                <option value="aes-256-gcm">aes-256-gcm</option>
                <option value="aes-128-gcm">aes-128-gcm</option>
                <option value="chacha20-ietf-poly1305">chacha20-ietf-poly1305</option>
                <option value="2022-blake3-aes-256-gcm">2022-blake3-aes-256-gcm</option>
                <option value="2022-blake3-aes-128-gcm">2022-blake3-aes-128-gcm</option>
              </select>
            </label>
            <label><span>密码</span><input name="ss_password" type="text" placeholder="密码"></label>
          </div>

          <!-- VMess/VLESS Specific -->
          <div id="vmess-fields"
            style="display:none; grid-column:1/-1; display:grid; grid-template-columns:1fr 1fr; gap:16px;">
            <label><span>UUID</span><input name="vmess_uuid" type="text"
                placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"></label>
            <label>
              <span>AlterID (VMess)</span>
              <input name="vmess_alterid" type="number" value="0" placeholder="0">
            </label>
            <label>
              <span>加密方式</span>
              <select name="vmess_security">
                <option value="auto">auto</option>
                <option value="aes-128-gcm">aes-128-gcm</option>
                <option value="chacha20-poly1305">chacha20-poly1305</option>
                <option value="none">none</option>
              </select>
            </label>
            <label>
              <span>流控 (VLESS)</span>
              <select name="vless_flow">
                <option value="">无</option>
                <option value="xtls-rprx-vision">xtls-rprx-vision</option>
                <option value="xtls-rprx-vision-udp443">xtls-rprx-vision-udp443</option>
              </select>
            </label>
          </div>

          <!-- Trojan Specific -->
          <div id="trojan-fields" style="display:none; grid-column:1/-1;">
            <label><span>密码</span><input name="trojan_password" type="text" placeholder="密码"></label>
          </div>

          <!-- HTTP/SOCKS5 Specific -->
          <div id="proxy-fields"
            style="display:none; grid-column:1/-1; display:grid; grid-template-columns:1fr 1fr; gap:16px;">
            <label><span>用户名</span><input name="proxy_username" type="text" placeholder="可选"></label>
            <label><span>密码</span><input name="proxy_password" type="text" placeholder="可选"></label>
          </div>

          <!-- Network Settings -->
          <div
            style="grid-column:1/-1; font-weight:600; font-size:14px; color:var(--text-primary); margin-top:16px; padding-bottom:8px; border-bottom:1px solid var(--border-color);">
            传输设置</div>
          <label>
            <span>传输协议</span>
            <select name="network" id="network-select">
              <option value="tcp">TCP</option>
              <option value="ws">WebSocket</option>
              <option value="h2">HTTP/2</option>
              <option value="grpc">gRPC</option>
              <option value="quic">QUIC</option>
            </select>
          </label>
          <label>
            <span>TLS</span>
            <select name="tls">
              <option value="">不启用</option>
              <option value="tls">TLS</option>
              <option value="xtls">XTLS</option>
            </select>
          </label>

          <!-- WebSocket Settings -->
          <div id="ws-fields"
            style="display:none; grid-column:1/-1; display:grid; grid-template-columns:1fr 1fr; gap:16px;">
            <label style="grid-column:1/-1"><span>WebSocket 路径</span><input name="ws_path" type="text"
                placeholder="/path"></label>
            <label style="grid-column:1/-1"><span>Host</span><input name="ws_host" type="text"
                placeholder="example.com"></label>
          </div>

          <!-- HTTP/2 Settings -->
          <div id="h2-fields"
            style="display:none; grid-column:1/-1; display:grid; grid-template-columns:1fr 1fr; gap:16px;">
            <label style="grid-column:1/-1"><span>HTTP/2 路径</span><input name="h2_path" type="text"
                placeholder="/path"></label>
            <label style="grid-column:1/-1"><span>Host</span><input name="h2_host" type="text"
                placeholder="example.com"></label>
          </div>

          <!-- gRPC Settings -->
          <div id="grpc-fields" style="display:none; grid-column:1/-1;">
            <label><span>gRPC ServiceName</span><input name="grpc_service" type="text" placeholder="ServiceName"></label>
          </div>

          <!-- TLS Settings -->
          <div id="tls-fields"
            style="display:none; grid-column:1/-1; display:grid; grid-template-columns:1fr 1fr; gap:16px;">
            <label style="grid-column:1/-1"><span>SNI</span><input name="tls_sni" type="text"
                placeholder="留空使用服务器地址"></label>
            <label style="grid-column:1/-1"><span>指纹 (Fingerprint)</span>
              <select name="tls_fingerprint">
                <option value="">不设置</option>
                <option value="chrome">Chrome</option>
                <option value="firefox">Firefox</option>
                <option value="safari">Safari</option>
                <option value="edge">Edge</option>
                <option value="random">随机</option>
              </select>
            </label>
          </div>
        </div>

        <!-- Other Settings -->
        <div
          style="display:none; grid-column:1/-1; font-weight:600; font-size:14px; color:var(--text-primary); margin-top:16px; padding-bottom:8px; border-bottom:1px solid var(--border-color);">
          其他设置</div>
        <label style="grid-column:1/-1"><span>FRouter 标签</span><input name="tags" type="text"
            placeholder="多个标签用逗号分隔, 例如: 香港,IPLC,游戏"></label>

        <div class="form-actions">
          <button type="button" id="node-modal-reset">重置</button>
          <button type="submit" class="primary">创建 FRouter</button>
        </div>
      </form>
    </div>
  </div>

  <div id="nodes-modal" class="modal">
    <div class="modal-backdrop"></div>
    <div class="modal-content" style="max-width: 760px; max-height: 90vh; overflow-y: auto;">
      <button id="nodes-modal-close" class="modal-close"
        style="position:absolute; top:24px; right:24px; background:none; border:none; color:var(--text-secondary); font-size:20px; cursor:pointer;">×</button>
      <form id="nodes-form" class="form-grid" novalidate>
        <h3 id="nodes-modal-title" style="grid-column:1/-1; margin-bottom:16px; font-size:18px; font-weight:600; color:var(--text-primary);">
          添加节点</h3>

        <label id="nodes-sharelink-row" style="grid-column:1/-1;">
          <span>分享链接 (可选)</span>
          <textarea name="shareLink" style="height:72px;" placeholder="vless:// / vmess:// / trojan:// / ss:// (支持 base64 订阅内容)"></textarea>
        </label>

        <label><span>节点名称 *</span><input name="name" type="text" required placeholder="例如: 香港01"></label>
        <label><span>服务器地址 *</span><input name="address" type="text" required placeholder="example.com 或 IP"></label>
        <label><span>端口 *</span><input name="port" type="number" min="1" max="65535" required placeholder="443"></label>
        <label>
          <span>协议 *</span>
          <select name="protocol" id="nodes-protocol-select" required>
            <option value="shadowsocks">Shadowsocks</option>
            <option value="vmess">VMess</option>
            <option value="vless">VLESS</option>
            <option value="trojan">Trojan</option>
          </select>
        </label>
        <label style="grid-column:1/-1;"><span>标签</span><input name="tags" type="text"
            placeholder="多个标签用逗号分隔, 例如: 香港,游戏"></label>

        <div
          style="grid-column:1/-1; font-weight:600; font-size:14px; color:var(--text-primary); margin-top:8px; padding-bottom:8px; border-bottom:1px solid var(--border-color);">
          认证信息</div>

        <div id="nodes-ss-fields"
          style="grid-column:1/-1; display:none; grid-template-columns:1fr 1fr; gap:16px;">
          <label>
            <span>加密方式</span>
            <select name="ss_method">
              <option value="aes-256-gcm">aes-256-gcm</option>
              <option value="aes-128-gcm">aes-128-gcm</option>
              <option value="chacha20-ietf-poly1305">chacha20-ietf-poly1305</option>
              <option value="2022-blake3-aes-256-gcm">2022-blake3-aes-256-gcm</option>
              <option value="2022-blake3-aes-128-gcm">2022-blake3-aes-128-gcm</option>
            </select>
          </label>
          <label><span>密码</span><input name="ss_password" type="text" placeholder="密码"></label>
        </div>

        <div id="nodes-vmess-fields"
          style="grid-column:1/-1; display:none; grid-template-columns:1fr 1fr; gap:16px;">
          <label><span>UUID</span><input name="vmess_uuid" type="text"
              placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"></label>
          <label>
            <span>AlterID (VMess)</span>
            <input name="vmess_alterid" type="number" value="0" placeholder="0">
          </label>
          <label>
            <span>加密方式</span>
            <select name="vmess_security">
              <option value="auto">auto</option>
              <option value="aes-128-gcm">aes-128-gcm</option>
              <option value="chacha20-poly1305">chacha20-poly1305</option>
              <option value="none">none</option>
            </select>
          </label>
          <label>
            <span>流控 (VLESS)</span>
            <select name="vless_flow">
              <option value="">无</option>
              <option value="xtls-rprx-vision">xtls-rprx-vision</option>
              <option value="xtls-rprx-vision-udp443">xtls-rprx-vision-udp443</option>
            </select>
          </label>
        </div>

        <div id="nodes-trojan-fields" style="grid-column:1/-1; display:none;">
          <label><span>密码</span><input name="trojan_password" type="text" placeholder="密码"></label>
        </div>

        <div
          style="grid-column:1/-1; font-weight:600; font-size:14px; color:var(--text-primary); margin-top:8px; padding-bottom:8px; border-bottom:1px solid var(--border-color);">
          传输设置</div>
        <label>
          <span>传输协议</span>
          <select name="network" id="nodes-network-select">
            <option value="tcp">TCP</option>
            <option value="ws">WebSocket</option>
            <option value="http">HTTP</option>
            <option value="h2">HTTP/2</option>
            <option value="grpc">gRPC</option>
          </select>
        </label>
        <label>
          <span>TLS</span>
          <select name="tls" id="nodes-tls-select">
            <option value="">不启用</option>
            <option value="tls">TLS</option>
          </select>
        </label>

        <div id="nodes-ws-fields"
          style="grid-column:1/-1; display:none; grid-template-columns:1fr 1fr; gap:16px;">
          <label style="grid-column:1/-1"><span>WebSocket 路径</span><input name="ws_path" type="text"
              placeholder="/path"></label>
          <label style="grid-column:1/-1"><span>Host</span><input name="ws_host" type="text"
              placeholder="example.com"></label>
        </div>

        <div id="nodes-http-fields"
          style="grid-column:1/-1; display:none; grid-template-columns:1fr 1fr; gap:16px;">
          <label style="grid-column:1/-1"><span>HTTP 路径</span><input name="h2_path" type="text"
              placeholder="/path"></label>
          <label style="grid-column:1/-1"><span>Host</span><input name="h2_host" type="text"
              placeholder="example.com"></label>
        </div>

        <div id="nodes-grpc-fields" style="grid-column:1/-1; display:none;">
          <label><span>gRPC ServiceName</span><input name="grpc_service" type="text" placeholder="ServiceName"></label>
        </div>

        <div id="nodes-tls-fields"
          style="grid-column:1/-1; display:none; grid-template-columns:1fr 1fr; gap:16px;">
          <label style="grid-column:1/-1"><span>SNI</span><input name="tls_sni" type="text"
              placeholder="留空使用服务器地址"></label>
          <label style="grid-column:1/-1"><span>指纹 (Fingerprint)</span>
            <select name="tls_fingerprint">
              <option value="">不设置</option>
              <option value="chrome">Chrome</option>
              <option value="firefox">Firefox</option>
              <option value="safari">Safari</option>
              <option value="edge">Edge</option>
              <option value="random">随机</option>
            </select>
          </label>
          <label style="grid-column:1/-1"><span>证书校验</span>
            <select name="tls_insecure">
              <option value="false">严格校验</option>
              <option value="true">跳过校验</option>
            </select>
          </label>
        </div>

        <div class="form-actions">
          <button type="button" id="nodes-modal-reset">重置</button>
          <button type="submit" class="primary">创建节点</button>
        </div>
      </form>
    </div>
  </div>

  <div id="config-modal" class="modal">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
      <button id="config-modal-close" class="modal-close"
        style="position:absolute; top:24px; right:24px; background:none; border:none; color:var(--text-secondary); font-size:20px; cursor:pointer;">×</button>
      <form id="config-form" class="form-grid">
        <h3 id="config-modal-title" style="grid-column:1/-1; margin-bottom:16px; font-size:18px; font-weight:600; color:var(--text-primary);">
          添加订阅</h3>
        <label><span>名称</span><input name="name" type="text" required placeholder="例如: My Server"></label>
        <label style="grid-column:1/-1"><span>订阅链接</span><input name="sourceUrl" type="url" required
            placeholder="https://..."></label>
        <label><span>更新间隔 (分钟，0=关闭)</span><input name="autoUpdateInterval" type="number" min="0" value="60"></label>
        <label style="grid-column:1/-1"><span>配置内容 (可选)</span><textarea name="payload"
            style="height:80px;"></textarea></label>
        <div class="form-actions">
          <button type="button" id="config-modal-reset">重置</button>
          <button type="submit" class="primary">保存订阅</button>
        </div>
      </form>
    </div>
  </div>

  <script src="../settings-schema.js"></script>
  <!-- Rule Templates (保留) -->
  <script src="../chain-editor/rule-templates.js"></script>
  <script type="module">
    import { createAPI, utils } from '../sdk/dist/vea-sdk.esm.js';
    const { formatTime, formatBytes, formatInterval, escapeHtml, parseNumber, parseList, sleep } = utils;

    (function () {
      const menu = document.getElementById("menu");
      const panels = document.querySelectorAll(".panel");
      const statusBar = document.getElementById("status");
      let currentPanel = "panel-home";
      let statusTimer = null;

      const api = createAPI('http://127.0.0.1:19080');

      function showStatus(message, type = "info", delay = 3200) {
        if (!message) {
          statusBar.classList.remove("visible", "success", "error", "info");
          statusBar.textContent = "";
          return;
        }
        statusBar.textContent = message;
        statusBar.classList.remove("success", "error", "info");
        statusBar.classList.add("visible", type);
        if (statusTimer) {
          clearTimeout(statusTimer);
        }
        if (delay > 0) {
          statusTimer = setTimeout(() => {
            statusBar.classList.remove("visible");
          }, delay);
        }
      }

      const SYSTEM_PROXY_DEFAULTS = ["localhost", "127.0.0.0/8", "::1"];
      let systemProxySettings = {
        enabled: false,
        ignoreHosts: [...SYSTEM_PROXY_DEFAULTS],
      };
      let frouterTags = [];
      let currentFRouterTab = "全部";

      let coreStatus = {
        enabled: false,
        running: false,
        binary: "",
      };
	      let froutersCache = [];
	      let nodesCache = [];
	      let configsCache = [];
	      let currentFRouterId = "";
	      let componentsCache = [];
	      let froutersPollHandle = null;
	      let nodesPollHandle = null;
	      let kernelLogsPollHandle = null;
	      let kernelLogOffset = 0;
	      let kernelLogSession = 0;
	      let kernelLogStartedAt = "";
	      let appLogsPollHandle = null;
	      let appLogOffset = 0;
	      let appLogStartedAt = "";
	      const ANSI_ESC = "\x1b";
	      const ANSI_ESC_SYMBOL = "␛";
	      let kernelLogAnsiState = createAnsiState();
	      let kernelLogAnsiCarry = "";
	      let appLogAnsiState = createAnsiState();
	      let appLogAnsiCarry = "";
	      let currentLogsTab = "kernel";
	      let kernelLogAutoScroll = true;
	      let kernelLogsPanelInitialized = false;
	      let appLogAutoScroll = true;
	      let appLogsPanelInitialized = false;
	      let logsTabsInitialized = false;
	      let nodesLoadInFlight = false;
	      let homeAutoTestInFlight = false;
	      let applyFRouterInFlight = false;
	      let applyFRouterPendingId = "";
		      const FROUTERS_POLL_INTERVAL = 1000;
		      const NODES_POLL_INTERVAL = 100; // 0.1s
		      const KERNEL_LOGS_POLL_INTERVAL = 800;
		      const FROUTER_STORAGE_KEY = "vea_selected_frouter_id";

	      function createAnsiState() {
	        return {
	          fg: null,
	          bg: null,
	          bold: false,
	          italic: false,
	          underline: false,
	        };
	      }

	      function resetKernelLogRender(pre) {
	        kernelLogAnsiState = createAnsiState();
	        kernelLogAnsiCarry = "";
	        if (pre) pre.innerHTML = "";
	      }

	      function resetAppLogRender(pre) {
	        appLogAnsiState = createAnsiState();
	        appLogAnsiCarry = "";
	        if (pre) pre.innerHTML = "";
	      }

	      function clampByte(value) {
	        const n = Number(value);
	        if (!Number.isFinite(n)) return 0;
	        if (n < 0) return 0;
	        if (n > 255) return 255;
	        return Math.floor(n);
	      }

	      function xterm256ToCss(n) {
	        const code = Number(n);
	        if (!Number.isFinite(code)) return null;
	        const idx = Math.max(0, Math.min(255, Math.floor(code)));

	        const base16 = [
	          [0, 0, 0],
	          [205, 0, 0],
	          [0, 205, 0],
	          [205, 205, 0],
	          [0, 0, 238],
	          [205, 0, 205],
	          [0, 205, 205],
	          [229, 229, 229],
	          [127, 127, 127],
	          [255, 0, 0],
	          [0, 255, 0],
	          [255, 255, 0],
	          [92, 92, 255],
	          [255, 0, 255],
	          [0, 255, 255],
	          [255, 255, 255],
	        ];

	        let rgb = null;
	        if (idx < 16) {
	          rgb = base16[idx];
	        } else if (idx <= 231) {
	          const c = idx - 16;
	          const r = Math.floor(c / 36);
	          const g = Math.floor((c % 36) / 6);
	          const b = c % 6;
	          const steps = [0, 95, 135, 175, 215, 255];
	          rgb = [steps[r], steps[g], steps[b]];
	        } else {
	          const v = 8 + (idx - 232) * 10;
	          rgb = [v, v, v];
	        }
	        return `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
	      }

	      function ansiStateToStyle(state) {
	        if (!state) return "";
	        let style = "";
	        if (state.fg) style += `color:${state.fg};`;
	        if (state.bg) style += `background-color:${state.bg};`;
	        if (state.bold) style += "font-weight:600;";
	        if (state.italic) style += "font-style:italic;";
	        if (state.underline) style += "text-decoration:underline;";
	        return style;
	      }

	      function wrapAnsiHtml(escapedText, state) {
	        if (!escapedText) return "";
	        const style = ansiStateToStyle(state);
	        if (!style) return escapedText;
	        return `<span style="${style}">${escapedText}</span>`;
	      }

	      function applySgrSequence(params, state) {
	        const parts = params ? params.split(";") : ["0"];
	        let i = 0;
	        while (i < parts.length) {
	          const raw = parts[i];
	          const code = raw === "" ? 0 : Number(raw);
	          if (!Number.isFinite(code)) {
	            i += 1;
	            continue;
	          }

	          if (code === 0) {
	            state.fg = null;
	            state.bg = null;
	            state.bold = false;
	            state.italic = false;
	            state.underline = false;
	            i += 1;
	            continue;
	          }

	          if (code === 1) {
	            state.bold = true;
	            i += 1;
	            continue;
	          }
	          if (code === 22) {
	            state.bold = false;
	            i += 1;
	            continue;
	          }
	          if (code === 3) {
	            state.italic = true;
	            i += 1;
	            continue;
	          }
	          if (code === 23) {
	            state.italic = false;
	            i += 1;
	            continue;
	          }
	          if (code === 4) {
	            state.underline = true;
	            i += 1;
	            continue;
	          }
	          if (code === 24) {
	            state.underline = false;
	            i += 1;
	            continue;
	          }
	          if (code === 39) {
	            state.fg = null;
	            i += 1;
	            continue;
	          }
	          if (code === 49) {
	            state.bg = null;
	            i += 1;
	            continue;
	          }

	          if (code >= 30 && code <= 37) {
	            state.fg = xterm256ToCss(code - 30);
	            i += 1;
	            continue;
	          }
	          if (code >= 90 && code <= 97) {
	            state.fg = xterm256ToCss(8 + (code - 90));
	            i += 1;
	            continue;
	          }
	          if (code >= 40 && code <= 47) {
	            state.bg = xterm256ToCss(code - 40);
	            i += 1;
	            continue;
	          }
	          if (code >= 100 && code <= 107) {
	            state.bg = xterm256ToCss(8 + (code - 100));
	            i += 1;
	            continue;
	          }

	          if (code === 38 || code === 48) {
	            const isFg = code === 38;
	            const mode = Number(parts[i + 1]);
	            if (mode === 5) {
	              const css = xterm256ToCss(parts[i + 2]);
	              if (css) {
	                if (isFg) state.fg = css;
	                else state.bg = css;
	              }
	              i += 3;
	              continue;
	            }
	            if (mode === 2) {
	              const r = clampByte(parts[i + 2]);
	              const g = clampByte(parts[i + 3]);
	              const b = clampByte(parts[i + 4]);
	              const css = `rgb(${r},${g},${b})`;
	              if (isFg) state.fg = css;
	              else state.bg = css;
	              i += 5;
	              continue;
	            }
	          }

	          i += 1;
	        }
	      }

	      function ansiToHtmlChunk(text, state) {
	        const src = String(text || "");
	        let out = "";
	        let segStart = 0;
	        let i = 0;

	        while (i < src.length) {
	          const ch = src[i];
	          if (ch !== ANSI_ESC && ch !== ANSI_ESC_SYMBOL) {
	            i += 1;
	            continue;
	          }

	          if (i > segStart) {
	            out += wrapAnsiHtml(escapeHtml(src.slice(segStart, i)), state);
	          }

	          if (i + 1 >= src.length) {
	            return { html: out, carry: src.slice(i) };
	          }
	          if (src[i + 1] !== "[") {
	            i += 1;
	            segStart = i;
	            continue;
	          }

	          let j = i + 2;
	          while (j < src.length) {
	            const c = src[j];
	            if (c >= "@" && c <= "~") break;
	            j += 1;
	          }
	          if (j >= src.length) {
	            return { html: out, carry: src.slice(i) };
	          }

	          const final = src[j];
	          const params = src.slice(i + 2, j);
	          if (final === "m") {
	            applySgrSequence(params, state);
	          }
	          i = j + 1;
	          segStart = i;
	        }

	        if (segStart < src.length) {
	          out += wrapAnsiHtml(escapeHtml(src.slice(segStart)), state);
	        }
	        return { html: out, carry: "" };
	      }

	      function appendKernelLogChunk(pre, chunk) {
	        if (!pre || !chunk) return;
	        const { html, carry } = ansiToHtmlChunk(kernelLogAnsiCarry + chunk, kernelLogAnsiState);
	        kernelLogAnsiCarry = carry || "";
	        if (html) {
	          pre.insertAdjacentHTML("beforeend", html);
	        }
	      }

	      function appendAppLogChunk(pre, chunk) {
	        if (!pre || !chunk) return;
	        const { html, carry } = ansiToHtmlChunk(appLogAnsiCarry + chunk, appLogAnsiState);
	        appLogAnsiCarry = carry || "";
	        if (html) {
	          pre.insertAdjacentHTML("beforeend", html);
	        }
	      }

	      function ensureFRoutersPolling() {
	        if (froutersPollHandle) {
	          return;
	        }
	        froutersPollHandle = setInterval(() => {
	          loadFRouters();
	        }, FROUTERS_POLL_INTERVAL);
	      }

	      function startNodesPolling() {
	        if (nodesPollHandle) {
	          return;
	        }
	        nodesPollHandle = setInterval(() => {
	          if (currentPanel === "panel-nodes") {
	            loadNodes();
	          }
	        }, NODES_POLL_INTERVAL);
	      }

	      function stopNodesPolling() {
	        if (!nodesPollHandle) {
	          return;
	        }
	        clearInterval(nodesPollHandle);
	        nodesPollHandle = null;
	      }

	      function ensureKernelLogsPanel() {
	        if (kernelLogsPanelInitialized) {
	          return;
	        }
	        kernelLogsPanelInitialized = true;

	        const refreshBtn = document.getElementById("kernel-log-refresh");
	        const copyBtn = document.getElementById("kernel-log-copy");
	        const autoScrollToggle = document.getElementById("kernel-log-autoscroll");
	        const logContainer = document.getElementById("kernel-log-container");

	        if (autoScrollToggle) {
	          kernelLogAutoScroll = Boolean(autoScrollToggle.checked);
	          autoScrollToggle.addEventListener("change", (e) => {
	            kernelLogAutoScroll = Boolean(e.target.checked);
	            if (kernelLogAutoScroll && logContainer) {
	              logContainer.scrollTop = logContainer.scrollHeight;
	            }
	          });
	        }

	        if (refreshBtn) {
	          refreshBtn.addEventListener("click", async () => {
	            kernelLogOffset = 0;
	            kernelLogSession = 0;
	            kernelLogStartedAt = "";
	            const pre = document.getElementById("kernel-log-content");
	            resetKernelLogRender(pre);
	            await loadKernelLogs();
	          });
	        }

	        if (copyBtn) {
	          copyBtn.addEventListener("click", async () => {
	            const pre = document.getElementById("kernel-log-content");
	            const text = pre ? pre.textContent : "";
	            if (!text) {
	              showStatus("暂无可复制内容", "info", 1500);
	              return;
	            }
	            try {
	              await navigator.clipboard.writeText(text);
	              showStatus("日志已复制到剪贴板", "success", 1600);
	            } catch (err) {
	              showStatus(`复制失败：${err.message}`, "error", 3000);
	            }
	          });
	        }
	      }

	      function ensureAppLogsPanel() {
	        if (appLogsPanelInitialized) {
	          return;
	        }
	        appLogsPanelInitialized = true;

	        const refreshBtn = document.getElementById("app-log-refresh");
	        const copyBtn = document.getElementById("app-log-copy");
	        const autoScrollToggle = document.getElementById("app-log-autoscroll");
	        const logContainer = document.getElementById("app-log-container");

	        if (autoScrollToggle) {
	          appLogAutoScroll = Boolean(autoScrollToggle.checked);
	          autoScrollToggle.addEventListener("change", (e) => {
	            appLogAutoScroll = Boolean(e.target.checked);
	            if (appLogAutoScroll && logContainer) {
	              logContainer.scrollTop = logContainer.scrollHeight;
	            }
	          });
	        }

	        if (refreshBtn) {
	          refreshBtn.addEventListener("click", async () => {
	            appLogOffset = 0;
	            appLogStartedAt = "";
	            const pre = document.getElementById("app-log-content");
	            resetAppLogRender(pre);
	            await loadAppLogs();
	          });
	        }

	        if (copyBtn) {
	          copyBtn.addEventListener("click", async () => {
	            const pre = document.getElementById("app-log-content");
	            const text = pre ? pre.textContent : "";
	            if (!text) {
	              showStatus("暂无可复制内容", "info", 1500);
	              return;
	            }
	            try {
	              await navigator.clipboard.writeText(text);
	              showStatus("日志已复制到剪贴板", "success", 1600);
	            } catch (err) {
	              showStatus(`复制失败：${err.message}`, "error", 3000);
	            }
	          });
	        }
	      }

	      function syncLogsTabUI() {
	        const tabs = document.getElementById("log-tabs");
	        const kernelCard = document.getElementById("kernel-log-card");
	        const appCard = document.getElementById("app-log-card");

	        if (kernelCard) {
	          kernelCard.style.display = currentLogsTab === "kernel" ? "" : "none";
	        }
	        if (appCard) {
	          appCard.style.display = currentLogsTab === "app" ? "" : "none";
	        }

	        if (tabs) {
	          tabs.querySelectorAll(".node-tab[data-log-tab]").forEach((tab) => {
	            tab.classList.toggle("active", tab.dataset.logTab === currentLogsTab);
	          });
	        }
	      }

	      function setLogsTab(tab) {
	        const next = tab === "app" ? "app" : "kernel";
	        if (next === currentLogsTab) {
	          return;
	        }
	        currentLogsTab = next;
	        syncLogsTabUI();
	        if (currentPanel === "panel-logs") {
	          if (currentLogsTab === "app") {
	            loadAppLogs();
	          } else {
	            loadKernelLogs();
	          }
	        }
	      }

	      function ensureLogsTabs() {
	        if (logsTabsInitialized) {
	          return;
	        }
	        logsTabsInitialized = true;
	        const tabs = document.getElementById("log-tabs");
	        if (!tabs) {
	          return;
	        }
	        tabs.addEventListener("click", (event) => {
	          const button = event.target.closest(".node-tab[data-log-tab]");
	          if (!button) {
	            return;
	          }
	          setLogsTab(button.dataset.logTab);
	        });
	        syncLogsTabUI();
	      }

	      function startKernelLogsPolling() {
	        if (kernelLogsPollHandle) {
	          return;
	        }
	        kernelLogsPollHandle = setInterval(() => {
	          if (currentPanel === "panel-logs" && currentLogsTab === "kernel") {
	            loadKernelLogs();
	          }
	        }, KERNEL_LOGS_POLL_INTERVAL);
	      }

	      function startAppLogsPolling() {
	        if (appLogsPollHandle) {
	          return;
	        }
	        appLogsPollHandle = setInterval(() => {
	          if (currentPanel === "panel-logs" && currentLogsTab === "app") {
	            loadAppLogs();
	          }
	        }, KERNEL_LOGS_POLL_INTERVAL);
	      }

	      function stopKernelLogsPolling() {
	        if (!kernelLogsPollHandle) {
	          return;
	        }
	        clearInterval(kernelLogsPollHandle);
	        kernelLogsPollHandle = null;
	      }

	      function stopAppLogsPolling() {
	        if (!appLogsPollHandle) {
	          return;
	        }
	        clearInterval(appLogsPollHandle);
	        appLogsPollHandle = null;
	      }

	      async function loadKernelLogs(options = {}) {
	        const metaEl = document.getElementById("kernel-log-meta");
	        const pre = document.getElementById("kernel-log-content");
	        const logContainer = document.getElementById("kernel-log-container");
	        if (!pre) return;

	        try {
	          const forceFromStart = Boolean(options && options.forceFromStart);
	          const since = forceFromStart ? 0 : kernelLogOffset;
	          const payload = await api.get(`/proxy/kernel/logs?since=${since}`);
	          const data = payload || {};
	          const session = Number(data.session || 0);
	          const startedAt = data.startedAt || "";
	          const lost = Boolean(data.lost);
	          const chunk = data.text || "";

	          const sessionChanged = session && session !== kernelLogSession;
	          const startedAtChanged = startedAt && startedAt !== kernelLogStartedAt;

	          // 新 session 不应从旧 offset 续读：否则会丢掉“kernel start ...”等关键起始信息。
	          if (!forceFromStart && (sessionChanged || startedAtChanged) && kernelLogOffset !== 0) {
	            kernelLogOffset = 0;
	            await loadKernelLogs({ forceFromStart: true });
	            return;
	          }

	          const shouldReset = lost || sessionChanged || startedAtChanged || kernelLogOffset === 0;
	          if (shouldReset) {
	            resetKernelLogRender(pre);
	          }
	          appendKernelLogChunk(pre, chunk);

	          kernelLogSession = session || kernelLogSession;
	          kernelLogStartedAt = startedAt || kernelLogStartedAt;
	          if (typeof data.to === "number") {
	            kernelLogOffset = data.to;
	          }

	          if (metaEl) {
	            const parts = [];
	            if (data.engine) {
	              parts.push(componentDisplayName(String(data.engine)));
	            } else {
	              parts.push("内核");
	            }
	            if (data.running === false) parts.push("已停止");
	            if (data.pid) parts.push(`pid ${data.pid}`);
	            if (startedAt) parts.push(`启动于 ${formatTime(startedAt)}`);
	            if (data.error) parts.push(`错误：${data.error}`);
	            metaEl.textContent = parts.length ? parts.join(" · ") : "-";
	          }

	          if (kernelLogAutoScroll && logContainer) {
	            logContainer.scrollTop = logContainer.scrollHeight;
	          }
	        } catch (err) {
	          if (metaEl) {
	            metaEl.textContent = `加载失败：${err.message}`;
	          }
	        }
	      }

	      async function loadAppLogs(options = {}) {
	        const metaEl = document.getElementById("app-log-meta");
	        const pre = document.getElementById("app-log-content");
	        const logContainer = document.getElementById("app-log-container");
	        if (!pre) return;

	        try {
	          const forceFromStart = Boolean(options && options.forceFromStart);
	          const since = forceFromStart ? 0 : appLogOffset;
	          const payload = await api.get(`/app/logs?since=${since}`);
	          const data = payload || {};
	          const startedAt = data.startedAt || "";
	          const lost = Boolean(data.lost);
	          const chunk = data.text || "";

	          const startedAtChanged = startedAt && startedAt !== appLogStartedAt;

	          if (!forceFromStart && startedAtChanged && appLogOffset !== 0) {
	            appLogOffset = 0;
	            await loadAppLogs({ forceFromStart: true });
	            return;
	          }

	          const shouldReset = lost || startedAtChanged || appLogOffset === 0;
	          if (shouldReset) {
	            resetAppLogRender(pre);
	          }
	          appendAppLogChunk(pre, chunk);

	          appLogStartedAt = startedAt || appLogStartedAt;
	          if (typeof data.to === "number") {
	            appLogOffset = data.to;
	          }

	          if (metaEl) {
	            const parts = ["应用"];
	            if (data.running === false) parts.push("已停止");
	            if (data.pid) parts.push(`pid ${data.pid}`);
	            if (startedAt) parts.push(`启动于 ${formatTime(startedAt)}`);
	            if (data.error) parts.push(`错误：${data.error}`);
	            metaEl.textContent = parts.length ? parts.join(" · ") : "-";
	          }

	          if (appLogAutoScroll && logContainer) {
	            logContainer.scrollTop = logContainer.scrollHeight;
	          }
	        } catch (err) {
	          if (metaEl) {
	            metaEl.textContent = `加载失败：${err.message}`;
	          }
	        }
	      }

      function getSavedFRouterId() {
        try {
          return localStorage.getItem(FROUTER_STORAGE_KEY) || "";
        } catch {
          return "";
        }
      }

      function persistFRouterId(frouterId) {
        try {
          localStorage.setItem(FROUTER_STORAGE_KEY, frouterId || "");
        } catch (err) {
          console.warn("Failed to persist FRouter selection:", err);
        }
      }

      function getCurrentFRouter() {
        if (!Array.isArray(froutersCache) || froutersCache.length === 0) {
          return null;
        }
        if (currentFRouterId) {
          const found = froutersCache.find((frouter) => frouter.id === currentFRouterId);
          if (found) return found;
        }
        return froutersCache[0] || null;
      }

      function updateFRouterSelectors() {
        const current = getCurrentFRouter();
        const selectedId = current ? current.id : "";
        if (selectedId && selectedId !== currentFRouterId) {
          currentFRouterId = selectedId;
          persistFRouterId(selectedId);
        }
        const options = Array.isArray(froutersCache)
          ? froutersCache
              .map((frouter) => `<option value="${escapeHtml(frouter.id)}">${escapeHtml(frouter.name || frouter.id)}</option>`)
              .join("")
          : "";
        ["chain-route-select"].forEach((id) => {
          const select = document.getElementById(id);
          if (!select) return;
          select.innerHTML = options || '<option value="">暂无 FRouter</option>';
          if (selectedId) {
            select.value = selectedId;
          }
        });
      }

      function setCurrentFRouter(frouterId, { notify = false, reloadGraph = true } = {}) {
        if (!Array.isArray(froutersCache) || froutersCache.length === 0) {
          currentFRouterId = "";
          updateFRouterSelectors();
          updateHomeFRouterMetrics();
          return;
        }
        const next = froutersCache.find((frouter) => frouter.id === frouterId) || froutersCache[0];
        currentFRouterId = next ? next.id : "";
        persistFRouterId(currentFRouterId);
        updateFRouterSelectors();
        renderFRouters(froutersCache, currentFRouterId);
        updateHomeFRouterMetrics();
        if (chainEditorInitialized && chainEditor) {
          chainEditor.setFRouterId(currentFRouterId);
          if (reloadGraph) {
            chainEditor.loadGraph();
          }
        }
        if (notify && next) {
          showStatus("已切换", "info", 2000);
        }
      }

      async function applyFRouterSelection(frouterId, { notify = false } = {}) {
        const nextId = String(frouterId || "").trim();
        if (!nextId) return;

        applyFRouterPendingId = nextId;
        if (applyFRouterInFlight) {
          return;
        }

        applyFRouterInFlight = true;
        try {
          while (applyFRouterPendingId) {
            const targetId = applyFRouterPendingId;
            applyFRouterPendingId = "";
            await applyFRouterSelectionOnce(targetId, { notify });
          }
        } finally {
          applyFRouterInFlight = false;
        }
      }

      async function applyFRouterSelectionOnce(frouterId, { notify = false } = {}) {
        let status = null;
        try {
          status = await api.proxy.status();
        } catch (err) {
          if (notify) {
            showStatus(`获取内核状态失败：${err.message}`, "error", 6000);
          }
          return;
        }

        coreStatus = status || {};
        updateCoreUI(coreStatus);

        const coreRunning = Boolean(status && status.running);
        if (!coreRunning) {
          if (notify) {
            showStatus("内核未运行：已切换 FRouter（下次启动生效）", "info", 2500);
          }
          await loadIPGeo();
          return;
        }

        const currentRunningId = status && typeof status.frouterId === "string" ? status.frouterId : "";
        if (currentRunningId && currentRunningId === frouterId) {
          if (notify) {
            showStatus("已是当前 FRouter", "info", 1500);
          }
          await loadIPGeo();
          return;
        }

        const wasSystemProxyEnabled = Boolean(systemProxySettings && systemProxySettings.enabled);
        const ignoreHosts = collectIgnoreHosts();

        if (notify) {
          showStatus("正在切换 FRouter…", "info", 2000);
        }

        // 系统代理开启时，重启内核前必须先关闭系统代理，避免“指向黑洞”断网。
        if (wasSystemProxyEnabled) {
          try {
            await api.put("/settings/system-proxy", {
              enabled: false,
              ignoreHosts,
            });
          } catch (err) {
            showStatus(`关闭系统代理失败：${err.message}`, "error", 6000);
            return;
          }
          await loadSystemProxySettings();
        }

        try {
          await api.post("/proxy/start", { frouterId });
        } catch (err) {
          showStatus(`切换失败：${err.message}`, "error", 6000);
          await refreshCoreStatus();
          await loadSystemProxySettings();
          await loadIPGeo();
          return;
        }

        await sleep(500);
        await refreshCoreStatus();

        if (wasSystemProxyEnabled) {
          try {
            await api.put("/settings/system-proxy", {
              enabled: true,
              ignoreHosts,
            });
          } catch (err) {
            showStatus(`系统代理未能恢复：${err.message}`, "warn", 6000);
          }
          await loadSystemProxySettings();
        }

        await loadIPGeo();
        if (notify) {
          showStatus("FRouter 已切换", "success", 2000);
        }
      }

      async function refreshCoreStatus({ notify = false } = {}) {
        try {
          const status = await api.proxy.status();
          coreStatus = status || {};
          updateCoreUI(coreStatus);

          if (notify && coreStatus.running) {
            showStatus("内核已启动", "success");
          }
        } catch (err) {
          console.error("Failed to refresh proxy status:", err);
        }
      }

      function updateCoreUI(status = {}) {
        if (!status || typeof status !== "object") {
          status = {};
        }
        const indicator = document.getElementById("core-state");
        const proxyToggle = document.getElementById("proxy-toggle");

        const coreRunning = Boolean(status.running);
        const systemProxyEnabled = Boolean(systemProxySettings && systemProxySettings.enabled);

        if (indicator) {
          indicator.className = coreRunning ? "badge active" : "badge";
          const engineLabel = coreRunning && status.engine ? componentDisplayName(status.engine) : "";
          indicator.textContent = coreRunning
            ? `核心：运行中${engineLabel ? `（${engineLabel}）` : ""}`
            : "核心：已停止";
        }

        if (!proxyToggle) {
          return;
        }

        // 根据运行状态更新按钮
        if (systemProxyEnabled) {
          proxyToggle.dataset.mode = "stop";
          proxyToggle.classList.add("active");
          proxyToggle.title = "关闭系统代理";
        } else {
          proxyToggle.dataset.mode = "start";
          proxyToggle.classList.remove("active");
          proxyToggle.title = coreRunning ? "启用系统代理（内核已在后台运行）" : "启用系统代理";
        }
      }

      // TUN status management
      let tunStatusCache = null;

      async function checkTUNStatus({ notify = false } = {}) {
        try {
          const status = await api.get("/tun/check");
          tunStatusCache = status || {};
          updateTUNUI(tunStatusCache);
          if (notify) {
            const text = status.configured
              ? `TUN 模式已配置 (${status.platform})`
              : `TUN 模式未配置 (${status.platform})`;
            showStatus(text, status.configured ? "success" : "info");
          }
        } catch (err) {
          tunStatusCache = { configured: false, error: err.message };
          updateTUNUI(tunStatusCache);
          if (notify) {
            showStatus(`检查 TUN 状态失败：${err.message}`, "error", 6000);
          }
        }
      }

      // TUN Settings state
      let tunSettingsCache = null;

      async function loadTUNSettings() {
        try {
          const cfg = await api.get("/proxy/config");
          tunSettingsCache = { enabled: cfg && cfg.inboundMode === "tun" };
          updateTUNToggle(tunSettingsCache);
        } catch (err) {
          console.error("Failed to load TUN settings:", err);
          tunSettingsCache = { enabled: false };
          updateTUNToggle(tunSettingsCache);
        }
      }

      // Engine Settings state
      let engineSettingsCache = null;

      function isCoreComponentInstalled(kind) {
        const list = Array.isArray(componentsCache) ? componentsCache : [];
        const target = list.find((item) => item && item.kind === kind);
        return Boolean(target && target.installDir);
      }

      function updateEngineSelectOptions() {
        const select = document.getElementById("engine-select");
        if (!select) return;

        Array.from(select.options).forEach((opt) => {
          const value = opt.value || "";
          const baseLabel = opt.dataset.label || opt.textContent || value || "-";
          if (!opt.dataset.label) {
            opt.dataset.label = baseLabel;
          }

          if (value === "auto") {
            opt.disabled = false;
            opt.textContent = baseLabel;
            return;
          }

          const installed = isCoreComponentInstalled(value);
          opt.disabled = !installed;
          opt.textContent = installed ? baseLabel : `${baseLabel}（未安装）`;
        });
      }

      async function loadEngineSettings() {
        const select = document.getElementById("engine-select");
        if (!select) return;
        try {
          const cfg = await api.get("/proxy/config");
          const preferred = cfg && cfg.preferredEngine ? cfg.preferredEngine : "auto";
          engineSettingsCache = { preferredEngine: preferred };
          select.value = preferred || "auto";
        } catch (err) {
          console.error("Failed to load engine settings:", err);
          engineSettingsCache = { preferredEngine: "auto" };
          select.value = "auto";
        } finally {
          updateEngineSelectOptions();
        }
      }

      async function updateEngineSetting(preferredEngine) {
        const select = document.getElementById("engine-select");
        if (!select) return;

        const normalized = ["auto", "singbox", "clash"].includes(preferredEngine)
          ? preferredEngine
          : "auto";

        select.disabled = true;

        let prevEngine = "auto";
        try {
          if (engineSettingsCache && engineSettingsCache.preferredEngine) {
            prevEngine = engineSettingsCache.preferredEngine;
          } else {
            const cfg = await api.get("/proxy/config");
            prevEngine = cfg && cfg.preferredEngine ? cfg.preferredEngine : "auto";
          }
        } catch {
          prevEngine = "auto";
        }

        if (normalized === prevEngine) {
          select.value = normalized;
          select.disabled = false;
          updateEngineSelectOptions();
          return;
        }

        const ignoreHosts = collectIgnoreHosts();
        let wasRunning = false;
        try {
          const status = await api.proxy.status();
          coreStatus = status || coreStatus;
          wasRunning = Boolean(status && status.running);
        } catch {
          wasRunning = false;
        }

        const wasSystemProxyEnabled = Boolean(systemProxySettings && systemProxySettings.enabled);
        let systemProxyDisabled = false;
        let configSaved = false;

        async function refreshEngineSwitchUI({ alwaysLoadSystemProxy = false, restoreSystemProxy = null } = {}) {
          await refreshCoreStatus();

          if (typeof restoreSystemProxy === "function") {
            await restoreSystemProxy();
          }

          if (alwaysLoadSystemProxy || (wasSystemProxyEnabled && systemProxyDisabled)) {
            await loadSystemProxySettings();
          }

          await loadIPGeo();

          if (currentPanel === "panel-logs") {
            kernelLogOffset = 0;
            kernelLogSession = 0;
            kernelLogStartedAt = "";
            const pre = document.getElementById("kernel-log-content");
            resetKernelLogRender(pre);
            await loadKernelLogs();
          }
        }

        try {
          const updated = await api.put("/proxy/config", { preferredEngine: normalized });
          configSaved = true;
          engineSettingsCache = { preferredEngine: updated && updated.preferredEngine ? updated.preferredEngine : normalized };
          select.value = engineSettingsCache.preferredEngine || normalized;

          const selectedFRouter = getCurrentFRouter();
          const frouterId = selectedFRouter && selectedFRouter.id
            ? selectedFRouter.id
            : (updated && updated.frouterId ? updated.frouterId : (coreStatus && coreStatus.frouterId ? coreStatus.frouterId : ""));
          if (!frouterId) {
            showStatus("内核偏好已保存，但未选择 FRouter，无法重启内核", "warn", 4000);
            return;
          }

          if (wasSystemProxyEnabled) {
            try {
              await api.put("/settings/system-proxy", { enabled: false, ignoreHosts });
              systemProxyDisabled = true;
              await loadSystemProxySettings();
            } catch (err) {
              showStatus(`关闭系统代理失败：${err.message}`, "error", 6000);
              return;
            }
          }

          showStatus(wasRunning ? "正在重启内核..." : "正在启动内核...", "info", 2000);
          await api.post("/proxy/start", { frouterId });
          await sleep(500);

          await refreshEngineSwitchUI({
            restoreSystemProxy: async () => {
              if (!wasSystemProxyEnabled || !systemProxyDisabled) return;
              try {
                await api.put("/settings/system-proxy", { enabled: true, ignoreHosts });
              } catch (err) {
                showStatus(`系统代理未能恢复：${err.message}`, "warn", 6000);
              }
            },
          });

          const actualEngine = coreStatus && coreStatus.engine ? String(coreStatus.engine) : "";
          const action = wasRunning ? "重启" : "启动";
          if (normalized === "auto") {
            const label = actualEngine ? componentDisplayName(actualEngine) : "";
            showStatus(label ? `内核已${action}（自动：${label}）` : `内核已${action}`, "success", 2000);
          } else if (actualEngine && actualEngine !== normalized) {
            showStatus(`内核已${action}，但实际运行：${componentDisplayName(actualEngine)}`, "warn", 5000);
          } else {
            const label = actualEngine ? componentDisplayName(actualEngine) : componentDisplayName(normalized);
            showStatus(label ? `内核已${action}（${label}）` : `内核已${action}`, "success", 2000);
          }
        } catch (err) {
          showStatus(`切换内核失败：${err.message}`, "error", 6000);
          if (configSaved && wasRunning) {
            select.value = prevEngine || "auto";
            engineSettingsCache = { preferredEngine: prevEngine || "auto" };

            try {
              await api.put("/proxy/config", { preferredEngine: prevEngine || "auto" });
            } catch {
              // ignore
            }

            const selectedFRouter = getCurrentFRouter();
            const frouterId = selectedFRouter && selectedFRouter.id
              ? selectedFRouter.id
              : (coreStatus && coreStatus.frouterId ? coreStatus.frouterId : "");
            if (frouterId) {
              try {
                await api.post("/proxy/start", { frouterId });
                await sleep(500);
              } catch {
                // ignore
              }
            }
          } else if (!configSaved) {
            select.value = prevEngine || "auto";
            engineSettingsCache = { preferredEngine: prevEngine || "auto" };
          } else {
            select.value = normalized;
            engineSettingsCache = { preferredEngine: normalized };
          }

          await refreshEngineSwitchUI({
            alwaysLoadSystemProxy: true,
            restoreSystemProxy: async () => {
              if (!wasSystemProxyEnabled || !systemProxyDisabled) return;
              if (!(coreStatus && coreStatus.running)) return;
              try {
                await api.put("/settings/system-proxy", { enabled: true, ignoreHosts });
              } catch {
                // ignore
              }
            },
          });
        } finally {
          select.disabled = false;
          updateEngineSelectOptions();
        }
      }

      // IP Geo info
      async function loadIPGeo() {
        const ipEl = document.getElementById("ip-geo-ip");
        const locEl = document.getElementById("ip-geo-location");
        if (!ipEl || !locEl) return;

        ipEl.textContent = "...";
        locEl.textContent = "正在获取";

        try {
          const data = await api.get("/ip/geo");
          if (data.error) {
            ipEl.textContent = "--";
            locEl.textContent = data.error;
            return;
          }
          ipEl.textContent = data.ip || "--";
          const loc = [data.location, data.isp].filter(Boolean).join(" | ");
          locEl.textContent = loc || "--";
        } catch (err) {
          ipEl.textContent = "--";
          locEl.textContent = "获取失败";
        }
      }

      // IP Geo refresh button
      const ipGeoRefreshBtn = document.getElementById("ip-geo-refresh");
      if (ipGeoRefreshBtn) {
        ipGeoRefreshBtn.addEventListener("click", () => {
          loadIPGeo();
        });
      }

      async function updateTUNSetting(enabled) {
        const prevEnabled = Boolean(tunSettingsCache && tunSettingsCache.enabled);

        // Windows：未以管理员身份运行时，提前提示并阻止启用（避免写入配置后立即失败）
        if (enabled) {
          try {
            const status = await api.get("/tun/check");
            tunStatusCache = status || tunStatusCache || {};
            updateTUNUI(tunStatusCache);

            if (status && status.platform === "windows" && !status.configured) {
              showStatus("Windows 下启用 TUN 需要管理员权限：请右键 Vea → 以管理员身份运行。", "error", 6000);
              tunSettingsCache = { enabled: prevEnabled };
              updateTUNToggle(tunSettingsCache);
              return;
            }
          } catch {
            // ignore: 让后端在启动/报错时给出明确提示
          }
        }

        try {
          const updated = await api.put("/proxy/config", { inboundMode: enabled ? "tun" : "mixed" });
          tunSettingsCache = { enabled: updated && updated.inboundMode === "tun" };
          updateTUNToggle(tunSettingsCache || { enabled: false });

          // 启用 TUN 时系统代理应该关闭（否则系统会指向一个不存在的本地端口）。
          if (enabled) {
            try {
              const response = await api.put("/settings/system-proxy", {
                enabled: false,
                ignoreHosts: collectIgnoreHosts(),
              });
              const data = response && response.settings ? response.settings : response;
              systemProxySettings = {
                enabled: Boolean(data.enabled),
                ignoreHosts: Array.isArray(data.ignoreHosts) ? data.ignoreHosts : systemProxySettings.ignoreHosts,
              };
              renderSystemProxy(systemProxySettings);
              updateCoreUI(coreStatus);
            } catch (err) {
              console.warn("Failed to disable system proxy when enabling TUN:", err);
            }
          }

          // 变更入站模式需要重启/启动内核，否则不会创建/释放 TUN 网卡。
          let status = null;
          try {
            status = await api.proxy.status();
            coreStatus = status || coreStatus;
          } catch {
            status = null;
          }

          const shouldStart = enabled || (status && status.running);
          if (shouldStart) {
            const selectedFRouter = getCurrentFRouter();
            const frouterId = selectedFRouter && selectedFRouter.id
              ? selectedFRouter.id
              : (updated && updated.frouterId ? updated.frouterId : "");
            if (!frouterId) {
              throw new Error("请先选择一个 FRouter");
            }
            showStatus(enabled ? "正在启动 TUN 内核..." : "正在重启内核...", "info", 2000);
            await api.post("/proxy/start", { frouterId });
          }

          await refreshCoreStatus();
          await checkTUNStatus();
          await loadSystemProxySettings();
          await loadIPGeo();
          showStatus(`TUN 模式已${enabled ? '启用' : '禁用'}`, "success", 2000);
        } catch (err) {
          showStatus(`更新 TUN 设置失败：${err.message}`, "error", 6000);

          // 恢复开关状态（并回滚配置，避免 UI/后端不一致）
          tunSettingsCache = { enabled: prevEnabled };
          updateTUNToggle(tunSettingsCache);
          try {
            await api.put("/proxy/config", { inboundMode: prevEnabled ? "tun" : "mixed" });
          } catch {
            // ignore
          }
        }
      }

      function updateTUNToggle(settings) {
        const tunToggle = document.getElementById("tun-toggle");
        if (tunToggle) {
          tunToggle.checked = Boolean(settings.enabled);
          // 不再禁用开关，让用户点击时自动检测
        }
      }

      function updateTUNUI(status = {}) {
        const tunCard = document.getElementById("tun-status-card");
        const tunValue = document.getElementById("tun-status-value");

        if (!tunCard || !tunValue) return;

        const configured = Boolean(status.configured);
        const platform = status.platform || "unknown";

        if (status.error) {
          tunValue.textContent = "检查失败";
          tunValue.style.color = "var(--error)";
          tunCard.title = `错误：${status.error}`;
        } else if (configured) {
          tunValue.textContent = "已配置";
          tunValue.style.color = "var(--success)";
          tunCard.title = `TUN 模式已在 ${platform} 上配置`;
        } else {
          tunValue.textContent = "未配置";
          tunValue.style.color = "var(--warning)";
          const setupCmd = status.setupCommand || "查看文档";
          tunCard.title = `点击查看配置方法：${setupCmd}`;
        }

        // Windows 非管理员：在 TUN 区域给出明确提示
        const winNeedAdmin = !status.error && platform === "windows" && !configured;
        const winHintText = "Windows 下启用 TUN 需要管理员权限：请右键 Vea → 以管理员身份运行。";

        const homeHint = document.getElementById("tun-permission-hint");
        if (homeHint) {
          if (winNeedAdmin) {
            homeHint.textContent = winHintText;
            homeHint.style.display = "block";
          } else {
            homeHint.textContent = "";
            homeHint.style.display = "none";
          }
        }

        const settingsHint = document.getElementById("tun-permission-hint-settings");
        if (settingsHint) {
          if (winNeedAdmin) {
            settingsHint.textContent = winHintText;
            settingsHint.style.display = "block";
          } else {
            settingsHint.textContent = "";
            settingsHint.style.display = "none";
          }
        }

        // 更新设置面板中的 TUN 状态
        const tunConfigStatus = document.getElementById("tun-config-status");
        const tunSetupBtn = document.getElementById("tun-setup-btn");

        if (tunConfigStatus) {
          if (status.error) {
            tunConfigStatus.textContent = `检查失败: ${status.error}`;
            tunConfigStatus.style.color = "var(--error)";
          } else if (configured) {
            tunConfigStatus.textContent = `已配置 (${platform})`;
            tunConfigStatus.style.color = "var(--success)";
          } else {
            tunConfigStatus.textContent = `未配置 (${platform})`;
            tunConfigStatus.style.color = "var(--warning)";
          }
        }

        if (tunSetupBtn) {
          tunSetupBtn.style.display = (!configured && platform === "linux") ? "block" : "none";
        }
      }

      async function showTUNStatusDialog() {
        showStatus("正在检查 TUN 状态...", "info");
        await checkTUNStatus({ notify: true });
      }

      // 配置 TUN - 直接调用 API
      async function setupTUN() {
        try {
          showStatus("正在配置 TUN 模式...", "info");
          await api.post("/tun/setup", {});
          showStatus("TUN 配置成功！", "success", 2000);
          await checkTUNStatus();
          // 配置成功后自动启用 TUN
          await updateTUNSetting(true);
        } catch (err) {
          showStatus(`TUN 配置失败：${err.message}`, "error", 5000);
        }
      }

      // Panel loaders

		      async function loadFRouters({ notify = false } = {}) {
		        try {
		          const payload = await api.get("/frouters");
	          const frouters = Array.isArray(payload.frouters) ? payload.frouters : [];
	          froutersCache = frouters;

	          if (!currentFRouterId) {
	            currentFRouterId = getSavedFRouterId();
	          }
	          if (currentFRouterId && !froutersCache.find((frouter) => frouter.id === currentFRouterId)) {
	            currentFRouterId = "";
	          }

          const current = getCurrentFRouter();
          if (current && current.id) {
            currentFRouterId = current.id;
            persistFRouterId(currentFRouterId);
          }

	          updateFRouterTabs(frouters);
	          renderFRouters(frouters, currentFRouterId);
	          updateFRouterSelectors();
	          updateHomeFRouterMetrics();
	          refreshCoreStatus();
	          if (notify) {
	            showStatus("FRouter 列表已刷新", "success");
	          }
	        } catch (err) {
	          showStatus(`加载 FRouter 失败：${err.message}`, "error", 6000);
	          froutersCache = [];
	          currentFRouterId = "";
	          updateFRouterSelectors();
	          updateHomeFRouterMetrics();
		        }
		      }

          async function loadNodes() {
            if (nodesLoadInFlight) {
              return;
            }
            nodesLoadInFlight = true;
            try {
              const payload = await api.get("/nodes");
              nodesCache = Array.isArray(payload.nodes) ? payload.nodes : [];
              if (currentPanel === "panel-nodes") {
                renderOrUpdateNodesPanel(nodesCache);
              }
            } catch (err) {
              console.error("加载节点失败:", err);
              if (currentPanel === "panel-nodes") {
                showStatus(`加载节点失败：${err.message}`, "error", 6000);
              }
            } finally {
              nodesLoadInFlight = false;
            }
          }
		
		      async function autoTestHomePanel({ notify = false } = {}) {
		        const frouter = getCurrentFRouter();
		        const id = frouter && frouter.id ? frouter.id : "";
		        if (!id) return;

	        if (homeAutoTestInFlight) {
	          return;
	        }
	        homeAutoTestInFlight = true;

	        let queued = false;
	        try {
	          await api.post(`/frouters/${id}/ping`);
	          queued = true;
	        } catch (err) {
	          console.error("主页自动测延迟失败:", err);
	          if (notify) {
	            showStatus(`自动测延迟失败：${err.message}`, "error", 4000);
	          }
	        }
	        try {
	          await api.post(`/frouters/${id}/speedtest`);
	          queued = true;
	        } catch (err) {
	          console.error("主页自动测速失败:", err);
	          if (notify) {
	            showStatus(`自动测速失败：${err.message}`, "error", 4000);
	          }
	        }
	        if (notify && queued) {
	          showStatus("已自动开始测速/测延迟", "info", 2000);
	        }
	        homeAutoTestInFlight = false;
	      }

      function updateFRouterTabs(frouters) {
        if (!nodeTabs) return;
        const tags = new Set();
        frouters.forEach((frouter) => {
          if (Array.isArray(frouter.tags)) {
            frouter.tags.forEach((tag) => {
              const trimmed = String(tag || "").trim();
              if (trimmed) {
                tags.add(trimmed);
              }
            });
          }
        });
        const sorted = ["全部", ...Array.from(tags).sort((a, b) => a.localeCompare(b, "zh-Hans-CN"))];
        frouterTags = sorted;
        if (!frouterTags.includes(currentFRouterTab)) {
          currentFRouterTab = "全部";
        }
        nodeTabs.innerHTML = frouterTags
          .map((tag) => {
            const active = tag === currentFRouterTab ? "active" : "";
            return `<div class=\"node-tab ${active}\" data-tag=\"${escapeHtml(tag)}\">${escapeHtml(tag)}</div>`;
          })
          .join("");
	      }

	      function getConfigNameById(configId) {
	        if (!configId) return "";
	        const list = Array.isArray(configsCache) ? configsCache : [];
	        const cfg = list.find((item) => item && item.id === configId);
	        return cfg?.name || "";
	      }

	      function formatSubscriptionLabel(configId) {
	        if (!configId) return "未归属订阅";
	        const name = getConfigNameById(configId);
	        return name || String(configId);
	      }

	      function groupNodesBySubscription(nodes) {
	        const all = Array.isArray(nodes) ? nodes : [];
	        const groupsMap = new Map();
	        for (const n of all) {
	          const key = n?.sourceConfigId ? String(n.sourceConfigId) : "";
	          if (!groupsMap.has(key)) {
	            groupsMap.set(key, { key, label: formatSubscriptionLabel(key), nodes: [] });
	          }
	          groupsMap.get(key).nodes.push(n);
	        }

	        for (const group of groupsMap.values()) {
	          group.nodes.sort((a, b) => {
	            const an = (a?.name || a?.id || "").toString();
	            const bn = (b?.name || b?.id || "").toString();
	            return an.localeCompare(bn, "zh-Hans-CN");
	          });
	        }

	        const order = new Map();
	        if (Array.isArray(configsCache)) {
	          configsCache.forEach((cfg, idx) => {
	            if (cfg?.id) order.set(String(cfg.id), idx);
	          });
	        }

	        return Array.from(groupsMap.values()).sort((a, b) => {
	          const aEmpty = !a.key;
	          const bEmpty = !b.key;
	          if (aEmpty && bEmpty) return 0;
	          if (aEmpty) return 1;
	          if (bEmpty) return -1;
	          const ao = order.has(a.key) ? order.get(a.key) : Number.MAX_SAFE_INTEGER;
	          const bo = order.has(b.key) ? order.get(b.key) : Number.MAX_SAFE_INTEGER;
	          if (ao !== bo) return ao - bo;
	          return a.label.localeCompare(b.label, "zh-Hans-CN");
	        });
	      }

	      let lastRenderedFRoutersHash = "";
	      let lastRenderedNodesStructureHash = "";

	      function nodesStructureHash(nodes) {
	        const all = Array.isArray(nodes) ? nodes : [];
	        if (all.length === 0) return "";
	        return all
	          .map((n) => {
	            const id = (n && n.id) || "";
	            const name = (n && n.name) || "";
	            const proto = (n && n.protocol) || "";
	            const addr = (n && n.address) || "";
	            const port = (n && n.port) || "";
	            const source = (n && n.sourceConfigId) || "";
	            const sourceName = source ? getConfigNameById(source) : "";
	            return `${id}|${name}|${proto}|${addr}|${port}|${source}|${sourceName}`;
	          })
	          .join(";");
	      }

	      function getNodeLatencyDisplay(n) {
	        let value = "--";
	        let cls = "";
	        let title = "";
	        if (n && n.lastLatencyError) {
	          value = "错误";
	          cls = "poor";
	          title = n.lastLatencyError;
	        } else if (n && typeof n.lastLatencyMs === "number" && n.lastLatencyMs > 0) {
	          value = `${n.lastLatencyMs}ms`;
	          if (n.lastLatencyMs < 100) cls = "good";
	          else if (n.lastLatencyMs < 300) cls = "fair";
	          else cls = "poor";
	        }
	        return { value, cls, title };
	      }

	      function getNodeSpeedDisplay(n) {
	        let value = "--";
	        let cls = "";
	        let title = "";
	        if (n && n.lastSpeedError) {
	          value = "错误";
	          cls = "poor";
	          title = n.lastSpeedError;
	        } else if (n && typeof n.lastSpeedMbps === "number" && n.lastSpeedMbps > 0) {
	          const fixed = n.lastSpeedMbps >= 10 ? n.lastSpeedMbps.toFixed(1) : n.lastSpeedMbps.toFixed(2);
	          value = `${fixed} MB/s`;
	          if (n.lastSpeedMbps > 5) cls = "good";
	          else if (n.lastSpeedMbps > 1) cls = "fair";
	          else cls = "poor";
	        }
	        return { value, cls, title };
	      }

	      function renderOrUpdateNodesPanel(nodes) {
	        const all = Array.isArray(nodes) ? nodes : [];
	        if (all.length === 0) {
	          lastRenderedNodesStructureHash = "";
	          renderNodesPanel(all);
	          return;
	        }

	        const nextHash = nodesStructureHash(all);
	        if (nextHash !== lastRenderedNodesStructureHash) {
	          lastRenderedNodesStructureHash = nextHash;
	          renderNodesPanel(all);
	          return;
	        }

	        updateNodesMetrics(all);
	      }

	      function updateNodesMetrics(nodes) {
	        const tbody = document.querySelector("#nodes-table tbody");
	        if (!tbody) return;

	        const rowMap = new Map();
	        tbody.querySelectorAll('tr[data-id]').forEach((row) => {
	          const id = row.dataset.id || "";
	          if (id) rowMap.set(id, row);
	        });
	        if (rowMap.size !== nodes.length) {
	          renderNodesPanel(nodes);
	          return;
	        }

	        for (const n of nodes) {
	          const id = (n && n.id) || "";
	          if (!id) continue;
	          const row = rowMap.get(id);
	          if (!row) {
	            renderNodesPanel(nodes);
	            return;
	          }

	          const latencyEl = row.querySelector('[data-metric="latency"]');
	          const speedEl = row.querySelector('[data-metric="speed"]');
	          if (!latencyEl || !speedEl) {
	            renderNodesPanel(nodes);
	            return;
	          }

	          const latency = getNodeLatencyDisplay(n);
	          latencyEl.textContent = latency.value;
	          latencyEl.className = `node-metric-value${latency.cls ? " " + latency.cls : ""}`;
	          latencyEl.title = latency.title || "";

	          const speed = getNodeSpeedDisplay(n);
	          speedEl.textContent = speed.value;
	          speedEl.className = `node-metric-value${speed.cls ? " " + speed.cls : ""}`;
	          speedEl.title = speed.title || "";
	        }
	      }
	      function renderNodesPanel(nodes) {
	        const tbody = document.querySelector("#nodes-table tbody");
	        if (!tbody) return;

	        const all = Array.isArray(nodes) ? nodes : [];
	        if (all.length === 0) {
	          tbody.innerHTML = `
	            <tr>
	              <td colspan="6" style="text-align:center; color:var(--text-secondary); padding:24px;">暂无节点</td>
	            </tr>
	          `;
	          return;
	        }

	        const groups = groupNodesBySubscription(all);
	        tbody.innerHTML = groups
	          .map((group) => {
	            const pillText = group.key ? "订阅" : "未归属";
	            const header = `
	              <tr class="node-group-row" data-group="${escapeHtml(group.key || "unbound")}">
	                <td colspan="6">
	                  <div class="node-group-label">
	                    <span class="node-group-pill">${escapeHtml(pillText)}</span>
	                    <span class="node-group-name">${escapeHtml(group.label)}</span>
	                    <span class="node-group-count">${group.nodes.length} 个</span>
	                  </div>
	                </td>
	              </tr>
	            `;

		            const rows = group.nodes
		              .map((n) => {
		                const id = n.id || "";
		                const name = n.name || n.id || "未命名节点";
		                const proto = (n.protocol || "").toUpperCase() || "UNKNOWN";
		                const addr = n.address ? `${n.address}:${n.port || ""}` : "-";

		                const latency = getNodeLatencyDisplay(n);
		                const speed = getNodeSpeedDisplay(n);

		                const editButton = `<button class="mini-btn" data-action="edit-node">编辑</button>`;
		                return `
		                  <tr class="node-card-row" data-id="${escapeHtml(id)}">
		                    <td colspan="6">
		                      <div class="node-card">
		                        <div class="node-card-top">
		                          <div class="node-card-title">
		                            <span class="node-card-name" title="${escapeHtml(name)}">${escapeHtml(name)}</span>
		                            <span class="node-card-protocol">${escapeHtml(proto)}</span>
		                          </div>
		                          <div class="node-card-actions">
		                            <button class="mini-btn" data-action="ping-node">测延迟</button>
		                            <button class="mini-btn" data-action="speedtest-node">测速</button>
		                            ${editButton}
		                          </div>
		                        </div>
		                        <div class="node-card-meta">
		                          <span class="node-card-addr" title="${escapeHtml(addr)}">${escapeHtml(addr)}</span>
		                          <span class="node-card-id" title="${escapeHtml(id)}">${escapeHtml(id)}</span>
		                        </div>
		                        <div class="node-card-stats">
		                          <div class="node-card-stat">
		                            <span>延迟</span>
		                            <span class="node-metric-value ${latency.cls}" data-metric="latency" title="${escapeHtml(latency.title)}">${escapeHtml(latency.value)}</span>
		                          </div>
		                          <div class="node-card-stat">
		                            <span>速度</span>
		                            <span class="node-metric-value ${speed.cls}" data-metric="speed" title="${escapeHtml(speed.title)}">${escapeHtml(speed.value)}</span>
		                          </div>
		                        </div>
		                      </div>
		                    </td>
		                  </tr>
		                `;
		              })
		              .join("");

	            return `${header}${rows}`;
	          })
	          .join("");
	      }

	      function renderFRouters(frouters, currentId = "") {
	        if (!nodeGrid) return;
	        let filtered = frouters;
        if (currentFRouterTab !== "全部") {
          filtered = frouters.filter((frouter) => Array.isArray(frouter.tags) && frouter.tags.includes(currentFRouterTab));
        }
        if (!Array.isArray(frouters) || frouters.length === 0) {
          nodeGrid.innerHTML = '<div class="empty-card">暂无 FRouter</div>';
          lastRenderedFRoutersHash = "empty";
          return;
        }

        if (!Array.isArray(filtered) || filtered.length === 0) {
          nodeGrid.innerHTML = '<div class="empty-card">当前标签下暂无 FRouter</div>';
          lastRenderedFRoutersHash = "empty-filtered";
          return;
        }

        const stateHash = JSON.stringify(filtered.map(r => ({
          id: r.id,
          name: r.name,
          tags: r.tags,
          edges: r.chainProxy && Array.isArray(r.chainProxy.edges) ? r.chainProxy.edges.length : 0,
          slots: r.chainProxy && Array.isArray(r.chainProxy.slots) ? r.chainProxy.slots.length : 0,
          lastLatencyMs: r.lastLatencyMs,
          lastSpeedMbps: r.lastSpeedMbps,
          lastSpeedError: r.lastSpeedError
        }))) + currentId + currentFRouterTab;

        if (stateHash === lastRenderedFRoutersHash) {
          return;
        }
        lastRenderedFRoutersHash = stateHash;

        nodeGrid.innerHTML = filtered
          .map((frouter) => {
            const rowId = escapeHtml(frouter.id);
            const edgeCount = frouter.chainProxy && Array.isArray(frouter.chainProxy.edges) ? frouter.chainProxy.edges.length : 0;
            const slotCount = frouter.chainProxy && Array.isArray(frouter.chainProxy.slots) ? frouter.chainProxy.slots.length : 0;
            const tagText = Array.isArray(frouter.tags) && frouter.tags.length
              ? frouter.tags.join(" · ")
              : "无标签";

	            let latencyValue = "延迟";
	            let latencyClass = "";
	            const latencyTitle = frouter.lastLatencyError
	              ? `延迟失败：${frouter.lastLatencyError}`
	              : "测延迟";
	            if (typeof frouter.lastLatencyMs === "number" && frouter.lastLatencyMs > 0) {
	              latencyValue = `${frouter.lastLatencyMs}ms`;
	              if (frouter.lastLatencyMs < 100) latencyClass = "good";
	              else if (frouter.lastLatencyMs < 300) latencyClass = "fair";
	              else latencyClass = "poor";
	            }

	            let speedValue = "速度";
	            let speedClass = "";
	            const speedTitle = frouter.lastSpeedError
	              ? `测速失败：${frouter.lastSpeedError}`
	              : "测速";
	            if (frouter.lastSpeedError) {
	              speedValue = "错误";
	              speedClass = "poor";
	            } else if (typeof frouter.lastSpeedMbps === "number" && frouter.lastSpeedMbps > 0) {
              const fixed = frouter.lastSpeedMbps >= 10 ? frouter.lastSpeedMbps.toFixed(1) : frouter.lastSpeedMbps.toFixed(2);
              speedValue = `${fixed} MB/s`;
              if (frouter.lastSpeedMbps > 5) speedClass = "good";
              else if (frouter.lastSpeedMbps > 1) speedClass = "fair";
              else speedClass = "poor";
            }

            const selectedClass = frouter.id === currentId ? "active" : "";

            return `
          <div class="node-row ${selectedClass}" data-id="${rowId}">
            <div class="node-row-main">
              <div class="node-row-title">
		                <div class="node-row-name">${escapeHtml(frouter.name || "未命名 FRouter")}</div>
                <div class="node-row-meta">边: ${edgeCount} · 槽: ${slotCount} · ${escapeHtml(tagText)}</div>
              </div>
              <div class="node-row-protocol">路由</div>
            </div>

	            <div class="node-row-metrics">
	              <div class="node-metric" data-action="ping-route" title="${escapeHtml(latencyTitle)}">
	                <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2"></path></svg>
	                <span class="node-metric-value ${latencyClass}">${latencyValue}</span>
	              </div>
	              <div class="node-metric" data-action="speed-route" title="${escapeHtml(speedTitle)}">
	                <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>
	                <span class="node-metric-value ${speedClass}">${speedValue}</span>
	              </div>
	            </div>
          </div>
        `;
          })
          .join("");
      }

      async function loadConfigs({ notify = false } = {}) {
        try {
          const configs = await api.get("/configs");
          configsCache = Array.isArray(configs) ? configs : [];
          renderConfigs(configsCache);
          renderOrUpdateNodesPanel(nodesCache);
          if (notify) {
            showStatus("配置列表已刷新", "success");
          }
        } catch (err) {
          showStatus(`加载配置失败：${err.message}`, "error", 6000);
        }
      }

      function renderConfigs(configs) {
        const tbody = document.querySelector("#config-table tbody");
        if (!Array.isArray(configs) || configs.length === 0) {
          tbody.innerHTML = '<tr><td colspan="6" class="empty">暂无配置</td></tr>';
          return;
        }
        tbody.innerHTML = configs
          .map((cfg) => {
            const syncErr = cfg.lastSyncError || "";
            const syncState = syncErr
              ? `<span class="badge error text-truncate" title="${escapeHtml(syncErr)}">失败：${escapeHtml(syncErr)}</span>`
              : '<span class="badge">正常</span>';
            const source = cfg.sourceUrl ? `<br /><div class="muted text-truncate" title="${escapeHtml(cfg.sourceUrl)}">${escapeHtml(cfg.sourceUrl)}</div>` : "";
            return `
          <tr data-id="${escapeHtml(cfg.id)}">
	            <td>${escapeHtml(cfg.name)}${source}</td>
	            <td><span class="badge">${escapeHtml(cfg.format)}</span></td>
	            <td>${formatInterval(cfg.autoUpdateInterval)}</td>
	            <td>${formatTime(cfg.lastSyncedAt)}</td>
	            <td>${syncState}</td>
	            <td>
	              <button class="ghost" data-action="edit-config">编辑</button>
	              <button class="ghost" data-action="pull-nodes">拉取节点</button>
	              <button class="danger" data-action="delete-config">删除</button>
	            </td>
	          </tr>
	        `;
	          })
	          .join("");
	      }

      function renderSystemProxy(settings) {
        if (!systemProxyIgnoreInput) return;
        const hosts = Array.isArray(settings.ignoreHosts) ? settings.ignoreHosts : [];
        systemProxyIgnoreInput.value = hosts.join("\n");
      }

      async function loadSystemProxySettings({ notify = false } = {}) {
        try {
          const payload = await api.get("/settings/system-proxy");
          const data = payload && payload.settings ? payload.settings : payload;
          systemProxySettings = {
            enabled: Boolean(data.enabled),
            ignoreHosts: Array.isArray(data.ignoreHosts) ? data.ignoreHosts : [...SYSTEM_PROXY_DEFAULTS],
          };
          renderSystemProxy(systemProxySettings);
          updateCoreUI(coreStatus);
          if (notify) {
            const msg = payload && payload.message ? payload.message : "系统代理设置已刷新";
            showStatus(msg, payload && payload.message ? "info" : "success");
          }
        } catch (err) {
          showStatus(`加载系统代理失败：${err.message}`, "error", 6000);
        }
      }

      function collectIgnoreHosts() {
        if (!systemProxyIgnoreInput) {
          return Array.isArray(systemProxySettings.ignoreHosts)
            ? [...systemProxySettings.ignoreHosts]
            : [...SYSTEM_PROXY_DEFAULTS];
        }
        return systemProxyIgnoreInput
          .value.split(/\r?\n/)
          .map((item) => item.trim())
          .filter(Boolean);
      }

      function summarizeHomeFRouterMetrics() {
        const route = getCurrentFRouter();
        if (!route) {
          return { latencyMs: null, speedMbps: null, speedError: "" };
        }
        const latencyMs = typeof route.lastLatencyMs === "number" && route.lastLatencyMs > 0
          ? route.lastLatencyMs
          : null;
        const speedError = route.lastSpeedError || "";
        const speedMbps = !speedError && typeof route.lastSpeedMbps === "number" && route.lastSpeedMbps > 0
          ? route.lastSpeedMbps
          : null;
        return { latencyMs, speedMbps, speedError };
      }

      function updateHomeFRouterMetrics() {
        const latencyEl = document.getElementById("home-node-latency");
        const speedEl = document.getElementById("home-node-speed");
        if (!latencyEl || !speedEl) return;

        const { latencyMs, speedMbps, speedError } = summarizeHomeFRouterMetrics();

        latencyEl.textContent = typeof latencyMs === "number" ? `${latencyMs}ms` : "--";

        if (speedError) {
          speedEl.textContent = "错误";
          speedEl.title = speedError;
          return;
        }

        speedEl.title = "";
        if (typeof speedMbps === "number") {
          const fixed = speedMbps >= 10 ? speedMbps.toFixed(1) : speedMbps.toFixed(2);
          speedEl.textContent = `${fixed} MB/s`;
        } else {
          speedEl.textContent = "--";
        }
      }

	      async function loadHomePanel({ notify = false } = {}) {
	        await Promise.all([
	          loadFRouters(),
          loadNodes(),
          loadComponents(),
          loadIPGeo(),
          refreshCoreStatus({ notify }),
          loadSystemProxySettings({ notify }),
          checkTUNStatus({ notify }),
          loadTUNSettings(),
          loadEngineSettings()
	        ]);
	        updateHomeFRouterMetrics();
          updateEngineSelectOptions();
	        autoTestHomePanel({ notify: true });
	      }

      async function handleProxyToggle() {
        if (!proxyToggleButton || proxyToggleButton.disabled) return;
        const mode = proxyToggleButton.dataset.mode || "start";
        proxyToggleButton.disabled = true;
        try {
          if (mode === "stop") {
            const response = await api.put("/settings/system-proxy", {
              enabled: false,
              ignoreHosts: collectIgnoreHosts(),
            });
            const data = response && response.settings ? response.settings : response;
            systemProxySettings = {
              enabled: Boolean(data.enabled),
              ignoreHosts: Array.isArray(data.ignoreHosts) ? data.ignoreHosts : systemProxySettings.ignoreHosts,
            };
            if (response && response.message) {
              showStatus(`系统代理已关闭，但提示: ${response.message}`, "warn", 4000);
            } else {
              showStatus("系统代理已关闭", "info");
            }
          } else {
            let status = null;
            try {
              status = await api.proxy.status();
              coreStatus = status || coreStatus;
            } catch {
              status = null;
            }

            // 内核未运行：先启动内核（不依赖系统代理）
            if (!status || !status.running) {
              const selectedFRouter = getCurrentFRouter();
              const frouterId = selectedFRouter && selectedFRouter.id ? selectedFRouter.id : "";
              if (!frouterId) {
                throw new Error("请先选择一个 FRouter");
              }
              await api.post("/proxy/start", { frouterId });
              // 等待核心完全启动后再启用系统代理
              await new Promise((r) => setTimeout(r, 500));
            }
            const response = await api.put("/settings/system-proxy", {
              enabled: true,
              ignoreHosts: collectIgnoreHosts(),
            });

            // 立即更新全局状态
            const data = response && response.settings ? response.settings : response;
            systemProxySettings = {
              enabled: Boolean(data.enabled),
              ignoreHosts: Array.isArray(data.ignoreHosts) ? data.ignoreHosts : systemProxySettings.ignoreHosts,
            };

            if (response && response.message) {
              showStatus(response.message, "warn", 4000);
            } else {
              showStatus("系统代理已启用", "success");
            }
          }
        } catch (err) {
          showStatus(`操作失败：${err.message}`, "error", 6000);
        } finally {
          proxyToggleButton.disabled = false;
          await refreshCoreStatus();
          await loadSystemProxySettings();
          await loadIPGeo();
        }
      }

      // 组件安装轮询定时器
      let componentPollTimer = null;

      function normalizeComponents(components) {
        const list = Array.isArray(components) ? components : [];

        const singbox = list.find((item) => item && item.kind === "singbox") || {
          id: "",
          name: "sing-box",
          kind: "singbox",
          lastInstalledAt: "",
          installDir: "",
          lastVersion: "",
          checksum: "",
          lastSyncError: "",
          meta: { repo: "SagerNet/sing-box" },
        };

        const clash = list.find((item) => item && item.kind === "clash") || {
          id: "",
          name: "clash",
          kind: "clash",
          lastInstalledAt: "",
          installDir: "",
          lastVersion: "",
          checksum: "",
          lastSyncError: "",
          meta: { repo: "MetaCubeX/mihomo" },
        };

        const rest = list.filter((item) => {
          if (!item || typeof item !== "object") return false;
          if (item.kind === "singbox") return item !== singbox;
          if (item.kind === "clash") return item !== clash;
          return true;
        });

        return [singbox, clash, ...rest];
      }

      function renderComponents(components) {
        const tbody = document.querySelector("#component-table tbody");
        if (!tbody) return;
        const normalized = normalizeComponents(components);

        // 检查是否有组件正在安装
        const installing = normalized.some(c => c.installStatus === 'downloading' || c.installStatus === 'extracting');
        if (installing && !componentPollTimer) {
          componentPollTimer = setInterval(() => loadComponents(), 1000);
        } else if (!installing && componentPollTimer) {
          clearInterval(componentPollTimer);
          componentPollTimer = null;
        }

        tbody.innerHTML = normalized
          .map((component) => {
            const id = escapeHtml(component.id || "");
            const name = escapeHtml(component.name || "-");
            const kind = escapeHtml(componentDisplayName(component.kind));
            const version = escapeHtml(component.lastVersion || "-");
            const installDir = escapeHtml(component.installDir || "-");
            const installedAt = formatTime(component.lastInstalledAt);
            let statusText;
            let actionBtn = '';

            // 检查安装状态
            const installStatus = component.installStatus || '';
            const installProgress = component.installProgress || 0;
            const installMessage = component.installMessage || '';

            if (installStatus === 'downloading' || installStatus === 'extracting') {
              // 正在安装中，显示进度条
              statusText = `
            <div class="install-progress">
              <div class="progress-bar">
                <div class="progress-fill" style="width: ${installProgress}%"></div>
              </div>
              <span class="progress-text">${escapeHtml(installMessage)} (${installProgress}%)</span>
            </div>
          `;
              actionBtn = `<button class="ghost" disabled>安装中...</button>`;
            } else if (installStatus === 'error' || component.lastSyncError) {
              const errMsg = installMessage || component.lastSyncError || '未知错误';
              statusText = `<span class="badge error">失败：${escapeHtml(errMsg)}</span>`;
              actionBtn = `<button class="primary" data-action="update-component">重试</button>`;
            } else if (component.installDir) {
              statusText = '<span class="badge">已安装</span>';
              actionBtn = `<button class="ghost" data-action="update-component">更新</button>`;
            } else {
              statusText = '<span class="badge warn">未安装</span>';
              actionBtn = `<button class="primary" data-action="update-component">安装</button>`;
            }

            const isCoreComponent = component.kind === "singbox" || component.kind === "clash";
            const uninstallBtn = (isCoreComponent && component.installDir && installStatus !== 'downloading' && installStatus !== 'extracting')
              ? '<button class="danger" data-action="uninstall-component">卸载</button>'
              : '';
            const deleteBtn = isCoreComponent ? '' : '<button class="danger" data-action="delete-component">删除</button>';

            return `
          <tr data-id="${id}" data-kind="${escapeHtml(component.kind)}">
            <td>${name}</td>
            <td><span class="badge">${kind}</span></td>
            <td>${version}</td>
            <td><span class="muted">${installDir}</span></td>
            <td>${installedAt}</td>
            <td>${statusText}</td>
            <td>
              ${actionBtn}
              ${uninstallBtn}
              ${deleteBtn}
            </td>
          </tr>
        `;
          })
          .join("");
      }

      async function loadComponents({ notify = false } = {}) {
        try {
          const components = await api.get("/components");
          componentsCache = Array.isArray(components) ? components : [];
          renderComponents(componentsCache);
          updateEngineSelectOptions();
          await refreshCoreStatus();
          if (notify) {
            showStatus("组件列表已刷新", "success");
          }
        } catch (err) {
          showStatus(`加载组件失败：${err.message}`, "error", 6000);
          componentsCache = [];
          renderComponents([]);
          updateEngineSelectOptions();
          await refreshCoreStatus();
        }
      }

      function componentDisplayName(kind) {
        switch (kind) {
          case "singbox":
            return "sing-box";
          case "clash":
            return "Clash";
          default:
            return kind || "组件";
        }
      }

      async function ensureComponent(kind) {
        const pretty = componentDisplayName(kind);
        try {
          let components = [];
          try {
            components = await api.get("/components");
          } catch {
            components = [];
          }
          componentsCache = Array.isArray(components) ? components : [];
          let target = Array.isArray(components) ? components.find((item) => item.kind === kind) : null;
          if (!target) {
            target = await api.post("/components", { kind });
          }
          await api.post(`/components/${target.id}/install`);
          showStatus(`${pretty} 安装任务已触发`, "info", 2400);
          await loadComponents();
          await refreshCoreStatus();
        } catch (err) {
          showStatus(`${pretty} 安装失败：${err.message}`, "error", 6000);
        }
      }

      // ===== Chain List Editor (路由规则列表) =====
      let chainListEditor = null;
      let chainEditorInitialized = false;

      class ChainListEditor {
        constructor(container, apiClient) {
          this.container = container;
          this.api = apiClient;
          this.frouterId = '';
          this.edges = [];
          this.detourEdges = [];
          this.slots = [];
          this.nodes = [];
          this.dirty = false;
          this.draggedItem = null;
          this.editingEdgeId = null;
        }

        setFRouterId(id) {
          this.frouterId = id;
        }

        async init() {
          await this.loadGraph();
          this.bindEvents();
          this.initRuleTemplates();
        }

        async loadNodes() {
          try {
            const payload = await this.api.get('/nodes');
            this.nodes = Array.isArray(payload.nodes) ? payload.nodes : [];
          } catch (err) {
            console.error('加载节点失败:', err);
            this.nodes = [];
          }
        }

        async loadGraph() {
          try {
            await this.loadNodes();
            const path = this.frouterId
              ? `/frouters/${encodeURIComponent(this.frouterId)}/graph`
              : '/graph';
            const data = await this.api.get(path);
            const allEdges = Array.isArray(data.edges) ? data.edges : [];
            this.edges = allEdges.filter(e => (e?.from || '') === 'local');
            this.detourEdges = allEdges.filter(e => (e?.from || '') !== 'local');
            this.slots = Array.isArray(data.slots) ? data.slots : [];
            this.sortEdgesByPriority();
            this.render();
            this.dirty = false;
            this.updateStatus();
          } catch (err) {
            console.error('加载图数据失败:', err);
            this.edges = [];
            this.detourEdges = [];
            this.slots = [];
            this.render();
          }
        }

        sortEdgesByPriority() {
          this.edges.sort((a, b) => (b.priority || 0) - (a.priority || 0));
        }

        render() {
          const list = this.container.querySelector('#chain-rules-list');
          if (!list) return;

          if (this.edges.length === 0) {
            list.innerHTML = '<div class="chain-rules-empty">暂无路由规则，点击"添加规则"创建</div>';
            return;
          }

          list.innerHTML = this.edges.map((edge, index) => this.renderRuleItem(edge, index)).join('');
        }

        renderRuleItem(edge, index) {
          const target = this.getChainDisplay(edge);
          const targetClass = edge.to === 'direct' ? 'direct' : (edge.to === 'block' ? 'block' : '');
          const title = this.getRuleTitle(edge);
          const ruleInfo = `去向: ${target}`;
          const disabledClass = edge.enabled === false ? 'disabled' : '';

          return `
            <div class="chain-rule-item ${disabledClass}" data-edge-id="${escapeHtml(edge.id)}" data-index="${index}" draggable="true">
              <div class="chain-rule-drag">⋮⋮</div>
              <div class="chain-rule-main">
                <div class="chain-rule-target ${targetClass}">${escapeHtml(title)}</div>
                <div class="chain-rule-info">${escapeHtml(ruleInfo)}</div>
              </div>
              <div class="chain-rule-meta">
                <label class="chain-toggle">
                  <input type="checkbox" ${edge.enabled !== false ? 'checked' : ''} data-action="toggle">
                  <span class="chain-toggle-slider"></span>
                </label>
              </div>
              <div class="chain-rule-actions">
                <button data-action="edit" title="编辑">✎</button>
                <button class="delete" data-action="delete" title="删除">×</button>
              </div>
            </div>
          `;
        }

        getTargetDisplay(to) {
          if (to === 'direct') return '不代理（直连）';
          if (to === 'block') return '阻断';
          if (to && to.startsWith('slot-')) {
            const slot = this.slots.find(s => s.id === to);
            return slot?.name || to;
          }
          const node = this.nodes.find(n => n.id === to);
          return node?.name || to || '未知';
        }

        getChainDisplay(edge) {
          const to = (edge?.to && String(edge.to)) || '';
          if (to === 'direct' || to === 'block') {
            return this.getTargetDisplay(to);
          }
          const via = Array.isArray(edge?.via) ? edge.via : [];
          const hops = [to, ...via]
            .map(v => (v && String(v).trim()) || '')
            .filter(Boolean);
          if (hops.length === 0) return '未知';
          return hops.map(id => this.getTargetDisplay(id)).join(' → ');
        }

        fillRuleToSelect(selectEl, currentValue) {
          if (!selectEl) return;

          const value = (currentValue && String(currentValue)) || 'direct';
          const nodes = Array.isArray(this.nodes) ? [...this.nodes] : [];
          const slots = Array.isArray(this.slots) ? [...this.slots] : [];
          const seen = new Set();
          const optionHtml = (val, label) => `<option value="${escapeHtml(val)}">${escapeHtml(label)}</option>`;
          const hasValue = (v) => {
            if (v === 'direct' || v === 'block') return true;
            return nodes.some(n => n?.id === v) || slots.some(s => s?.id === v);
          };

          let html = '';
          if (value && !hasValue(value)) {
            html += optionHtml(value, `未知: ${value}`);
            seen.add(value);
          }

          const groups = groupNodesBySubscription(nodes);
          for (const group of groups) {
            const groupOptions = [];
            for (const n of group.nodes) {
              const id = n?.id;
              if (!id || seen.has(id)) continue;
              groupOptions.push(optionHtml(id, n?.name || id));
              seen.add(id);
            }
            if (groupOptions.length > 0) {
              html += `<optgroup label="${escapeHtml(group.label)}">${groupOptions.join('')}</optgroup>`;
            }
          }

          slots.sort((a, b) => {
            const an = (a?.name || a?.id || '').toString();
            const bn = (b?.name || b?.id || '').toString();
            return an.localeCompare(bn, "zh-Hans-CN");
          });

          const slotOptions = [];
          for (const s of slots) {
            const id = s?.id;
            if (!id || seen.has(id)) continue;
            const bound = s?.boundNodeId;
            let suffix = '';
            if (bound) {
              const bn = nodes.find(n => n?.id === bound);
              suffix = bn ? `（已绑定: ${bn?.name || bound}）` : `（已绑定: ${bound}）`;
            } else {
              suffix = '（未绑定）';
            }
            slotOptions.push(optionHtml(id, `${s?.name || id}${suffix}`));
            seen.add(id);
          }
          if (slotOptions.length > 0) {
            html += `<optgroup label="槽位">${slotOptions.join('')}</optgroup>`;
          }

          const builtinOptions = [];
          if (!seen.has('direct')) {
            builtinOptions.push(optionHtml('direct', '不代理（直连）'));
            seen.add('direct');
          }
          if (!seen.has('block')) {
            builtinOptions.push(optionHtml('block', '阻断'));
            seen.add('block');
          }
          if (builtinOptions.length > 0) {
            html += `<optgroup label="内置">${builtinOptions.join('')}</optgroup>`;
          }

          selectEl.innerHTML = html;
          selectEl.value = value;
        }

        fillChainHopSelect(selectEl, currentValue) {
          if (!selectEl) return;

          const value = (currentValue && String(currentValue)) || '';
          const nodes = Array.isArray(this.nodes) ? [...this.nodes] : [];
          const slots = Array.isArray(this.slots) ? [...this.slots] : [];
          const seen = new Set();
          const optionHtml = (val, label) => `<option value="${escapeHtml(val)}">${escapeHtml(label)}</option>`;
          const hasValue = (v) => {
            return nodes.some(n => n?.id === v) || slots.some(s => s?.id === v);
          };

          let html = '';
          if (value && !hasValue(value)) {
            html += optionHtml(value, `未知: ${value}`);
            seen.add(value);
          }

          const groups = groupNodesBySubscription(nodes);
          for (const group of groups) {
            const groupOptions = [];
            for (const n of group.nodes) {
              const id = n?.id;
              if (!id || seen.has(id)) continue;
              groupOptions.push(optionHtml(id, n?.name || id));
              seen.add(id);
            }
            if (groupOptions.length > 0) {
              html += `<optgroup label="${escapeHtml(group.label)}">${groupOptions.join('')}</optgroup>`;
            }
          }

          slots.sort((a, b) => {
            const an = (a?.name || a?.id || '').toString();
            const bn = (b?.name || b?.id || '').toString();
            return an.localeCompare(bn, "zh-Hans-CN");
          });

          const slotOptions = [];
          for (const s of slots) {
            const id = s?.id;
            if (!id || seen.has(id)) continue;
            const bound = s?.boundNodeId;
            let suffix = '';
            if (bound) {
              const bn = nodes.find(n => n?.id === bound);
              suffix = bn ? `（已绑定: ${bn?.name || bound}）` : `（已绑定: ${bound}）`;
            } else {
              suffix = '（未绑定）';
            }
            slotOptions.push(optionHtml(id, `${s?.name || id}${suffix}`));
            seen.add(id);
          }
          if (slotOptions.length > 0) {
            html += `<optgroup label="槽位">${slotOptions.join('')}</optgroup>`;
          }

          selectEl.innerHTML = html;

          if (value && seen.has(value)) {
            selectEl.value = value;
            return;
          }
          const firstOption = selectEl.querySelector('option');
          if (firstOption) {
            selectEl.value = firstOption.value;
          }
        }

        appendChainHopRow(listEl, currentValue) {
          if (!listEl) return;
          const row = document.createElement('div');
          row.className = 'rule-chain-item';
          const select = document.createElement('select');
          select.className = 'rule-chain-hop';
          this.fillChainHopSelect(select, currentValue);
          const delBtn = document.createElement('button');
          delBtn.type = 'button';
          delBtn.className = 'danger';
          delBtn.textContent = '×';
          delBtn.dataset.action = 'chain-remove';
          row.appendChild(select);
          row.appendChild(delBtn);
          listEl.appendChild(row);
        }

        renderChainEditor(edge) {
          const group = this.container.querySelector('#rule-chain-group');
          const list = this.container.querySelector('#rule-chain-list');
          const toSelect = this.container.querySelector('#rule-to');
          if (!group || !list || !toSelect) return;

          const to = toSelect.value || edge?.to || 'direct';
          const show = to !== 'direct' && to !== 'block';
          group.style.display = show ? 'block' : 'none';

          list.innerHTML = '';
          const via = Array.isArray(edge?.via) ? edge.via : [];
          for (const hop of via) {
            this.appendChainHopRow(list, hop);
          }
        }

        getRuleTitle(edge) {
          const ruleType = edge?.ruleType != null ? String(edge.ruleType) : '';
          const desc = edge?.description != null ? String(edge.description).trim() : '';

          if (!ruleType) {
            return desc || '默认（匹配所有流量）';
          }

          if (ruleType === 'route') {
            if (desc && desc.startsWith('模板:')) {
              return desc;
            }

            const tmpl = this.findMatchingTemplate(edge);
            if (tmpl?.name) {
              return `模板: ${tmpl.name}`;
            }

            const domains = Array.isArray(edge?.routeRule?.domains)
              ? edge.routeRule.domains.map(s => String(s).trim()).filter(Boolean)
              : [];
            const ips = Array.isArray(edge?.routeRule?.ips)
              ? edge.routeRule.ips.map(s => String(s).trim()).filter(Boolean)
              : [];
            const total = domains.length + ips.length;
            if (total > 0) {
              const first = domains.length > 0 ? domains[0] : ips[0];
              const kind = domains.length > 0 ? '域名' : 'IP';
              return `${kind}: ${first}${total > 1 ? ` +${total - 1}` : ''}`;
            }

            return desc || '自定义';
          }

          return desc || '自定义';
        }

        findMatchingTemplate(edge) {
          const rr = edge?.routeRule;
          if (!rr) return null;

          const normalize = (arr) => {
            if (!Array.isArray(arr)) return [];
            return arr
              .map(v => (v == null ? '' : String(v).trim()))
              .filter(Boolean)
              .sort();
          };

          const domains = normalize(rr.domains);
          const ips = normalize(rr.ips);
          const templates = (typeof RULE_TEMPLATES !== 'undefined' && RULE_TEMPLATES && Array.isArray(RULE_TEMPLATES.templates))
            ? RULE_TEMPLATES.templates
            : [];

          const equal = (a, b) => {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
              if (a[i] !== b[i]) return false;
            }
            return true;
          };

          for (const tmpl of templates) {
            const tr = tmpl?.rule || {};
            if (equal(domains, normalize(tr.domains)) && equal(ips, normalize(tr.ips))) {
              return tmpl;
            }
          }

          return null;
        }

        bindEvents() {
          const list = this.container.querySelector('#chain-rules-list');
          if (list) {
            list.addEventListener('dragstart', (e) => this.onDragStart(e));
            list.addEventListener('dragover', (e) => this.onDragOver(e));
            list.addEventListener('dragend', (e) => this.onDragEnd(e));
            list.addEventListener('drop', (e) => this.onDrop(e));
            list.addEventListener('click', (e) => this.onItemClick(e));
            list.addEventListener('change', (e) => this.onToggleChange(e));
          }

          const dialog = this.container.querySelector('#rule-edit-dialog');
          if (dialog) {
            dialog.addEventListener('click', (e) => {
              if (e.target === dialog) this.closeEditDialog();
            });
          }
          this.container.querySelector('#rule-dialog-close')?.addEventListener('click', () => this.closeEditDialog());
          this.container.querySelector('#rule-cancel')?.addEventListener('click', () => this.closeEditDialog());
          this.container.querySelector('#rule-save')?.addEventListener('click', () => this.saveEditDialog());
          this.container.querySelector('#rule-delete')?.addEventListener('click', () => this.deleteCurrentRule());

          this.container.querySelector('#rule-type')?.addEventListener('change', (e) => {
            const section = this.container.querySelector('#rule-route-section');
            if (section) section.style.display = e.target.value === 'route' ? 'block' : 'none';
          });

          this.container.querySelector('#rule-to')?.addEventListener('change', (e) => {
            const group = this.container.querySelector('#rule-chain-group');
            if (!group) return;
            const v = e.target.value;
            const show = v !== 'direct' && v !== 'block';
            group.style.display = show ? 'block' : 'none';
          });

          this.container.querySelector('#rule-chain-add')?.addEventListener('click', () => {
            const list = this.container.querySelector('#rule-chain-list');
            if (!list) return;
            const selects = list.querySelectorAll('.rule-chain-hop');
            const last = selects.length > 0 ? selects[selects.length - 1].value : '';
            this.appendChainHopRow(list, last);
          });

          this.container.querySelector('#rule-chain-list')?.addEventListener('click', (e) => {
            if (e.target?.dataset?.action !== 'chain-remove') return;
            e.target.closest('.rule-chain-item')?.remove();
          });
        }

        onDragStart(e) {
          const item = e.target.closest('.chain-rule-item');
          if (!item) return;
          this.draggedItem = item;
          item.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
        }

        onDragOver(e) {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          const item = e.target.closest('.chain-rule-item');
          if (!item || item === this.draggedItem) return;
          const list = this.container.querySelector('#chain-rules-list');
          list.querySelectorAll('.chain-rule-item').forEach(i => i.classList.remove('drag-over'));
          item.classList.add('drag-over');
        }

        onDragEnd(e) {
          this.container.querySelectorAll('.chain-rule-item').forEach(i => {
            i.classList.remove('dragging', 'drag-over');
          });
          this.draggedItem = null;
        }

        onDrop(e) {
          e.preventDefault();
          const dropTarget = e.target.closest('.chain-rule-item');
          if (!dropTarget || !this.draggedItem || dropTarget === this.draggedItem) return;

          const fromIndex = parseInt(this.draggedItem.dataset.index);
          const toIndex = parseInt(dropTarget.dataset.index);

          const [moved] = this.edges.splice(fromIndex, 1);
          this.edges.splice(toIndex, 0, moved);

          this.recalculatePriorities();
          this.render();
          this.markDirty();
        }

        recalculatePriorities() {
          const base = 100;
          this.edges.forEach((edge, index) => {
            edge.priority = base - index;
          });
        }

        onItemClick(e) {
          const action = e.target.closest('[data-action]')?.dataset.action;
          const item = e.target.closest('.chain-rule-item');
          if (!item || !action) return;
          if (action === 'toggle') return;

          const edgeId = item.dataset.edgeId;
          if (action === 'edit') {
            this.openEditDialog(edgeId);
          } else if (action === 'delete') {
            this.deleteRule(edgeId);
          }
        }

        onToggleChange(e) {
          if (e.target.dataset?.action !== 'toggle' && !e.target.closest('[data-action="toggle"]')) {
            if (e.target.type !== 'checkbox') return;
          }
          const item = e.target.closest('.chain-rule-item');
          if (!item) return;

          const edgeId = item.dataset.edgeId;
          const edge = this.edges.find(ed => ed.id === edgeId);
          if (edge) {
            edge.enabled = e.target.checked;
            this.markDirty();
            this.render();
          }
        }

        addRule() {
          const newEdge = {
            id: `rule-${crypto.randomUUID()}`,
            from: 'local',
            to: 'direct',
            via: [],
            priority: this.edges.length > 0 ? Math.max(...this.edges.map(e => e.priority || 0)) + 10 : 100,
            enabled: true,
            ruleType: '',
            routeRule: null,
            description: ''
          };
          this.edges.unshift(newEdge);
          this.recalculatePriorities();
          this.render();
          this.markDirty();
          this.openEditDialog(newEdge.id);
        }

        deleteRule(edgeId) {
          if (!confirm('确定要删除此规则？')) return;
          this.edges = this.edges.filter(e => e.id !== edgeId);
          this.recalculatePriorities();
          this.render();
          this.markDirty();
        }

        openEditDialog(edgeId) {
          const edge = this.edges.find(e => e.id === edgeId);
          if (!edge) return;

          this.editingEdgeId = edgeId;
          const dialog = this.container.querySelector('#rule-edit-dialog');
          const title = this.container.querySelector('#rule-dialog-title');
          const deleteBtn = this.container.querySelector('#rule-delete');

          if (title) title.textContent = edge.id.startsWith('rule-') && this.edges.indexOf(edge) === 0 ? '添加规则' : '编辑规则';
          if (deleteBtn) deleteBtn.style.display = 'block';

          const toSelect = this.container.querySelector('#rule-to');
          const typeSelect = this.container.querySelector('#rule-type');
          const enabledCheck = this.container.querySelector('#rule-enabled');
          const descInput = this.container.querySelector('#rule-description');
          const domainsInput = this.container.querySelector('#rule-domains');
          const ipsInput = this.container.querySelector('#rule-ips');
          const routeSection = this.container.querySelector('#rule-route-section');

          if (toSelect) this.fillRuleToSelect(toSelect, edge.to || 'direct');
          if (typeSelect) typeSelect.value = edge.ruleType || '';
          if (enabledCheck) enabledCheck.checked = edge.enabled !== false;
          if (descInput) descInput.value = edge.description || '';
          if (domainsInput) domainsInput.value = (edge.routeRule?.domains || []).join('\n');
          if (ipsInput) ipsInput.value = (edge.routeRule?.ips || []).join('\n');
          if (routeSection) routeSection.style.display = edge.ruleType === 'route' ? 'block' : 'none';
          this.renderChainEditor(edge);

          dialog?.classList.add('open');
        }

        closeEditDialog() {
          this.editingEdgeId = null;
          const dialog = this.container.querySelector('#rule-edit-dialog');
          dialog?.classList.remove('open');
        }

        saveEditDialog() {
          const edge = this.edges.find(e => e.id === this.editingEdgeId);
          if (!edge) return;

          const toSelect = this.container.querySelector('#rule-to');
          const typeSelect = this.container.querySelector('#rule-type');
          const enabledCheck = this.container.querySelector('#rule-enabled');
          const descInput = this.container.querySelector('#rule-description');
          const domainsInput = this.container.querySelector('#rule-domains');
          const ipsInput = this.container.querySelector('#rule-ips');

          edge.to = toSelect?.value || 'direct';
          edge.ruleType = typeSelect?.value || '';
          edge.enabled = enabledCheck?.checked !== false;
          edge.description = descInput?.value || '';
          if (edge.to === 'direct' || edge.to === 'block') {
            edge.via = [];
          } else {
            const hopSelects = Array.from(this.container.querySelectorAll('#rule-chain-list .rule-chain-hop'));
            edge.via = hopSelects
              .map(sel => (sel?.value || '').trim())
              .filter(v => v && v !== 'direct' && v !== 'block' && v !== 'local');
          }

          if (edge.ruleType === 'route') {
            const domains = (domainsInput?.value || '').split('\n').map(s => s.trim()).filter(Boolean);
            const ips = (ipsInput?.value || '').split('\n').map(s => s.trim()).filter(Boolean);
            edge.routeRule = { domains, ips };
          } else {
            edge.routeRule = null;
          }

          this.render();
          this.markDirty();
          this.closeEditDialog();
        }

        deleteCurrentRule() {
          if (this.editingEdgeId) {
            this.closeEditDialog();
            this.deleteRule(this.editingEdgeId);
          }
        }

        async saveGraph() {
          try {
            const path = this.frouterId
              ? `/frouters/${encodeURIComponent(this.frouterId)}/graph`
              : '/graph';

            const data = {
              edges: [...this.edges, ...this.detourEdges],
              slots: this.slots,
              positions: {}
            };

            await this.api.put(path, data);
            this.dirty = false;
            this.updateStatus();
            return { success: true };
          } catch (err) {
            console.error('保存失败:', err);
            return { success: false, error: err.message };
          }
        }

        markDirty() {
          this.dirty = true;
          this.updateStatus();
        }

        updateStatus() {
          const statusEl = this.container.querySelector('#chain-status');
          if (statusEl) {
            statusEl.textContent = this.dirty ? '有未保存的更改' : '已保存';
            statusEl.className = `toolbar-status ${this.dirty ? 'dirty' : ''}`;
          }
        }

        initRuleTemplates() {
          const categorySelect = this.container.querySelector('#rule-template-category');
          const templateSelect = this.container.querySelector('#rule-template-select');
          const applyBtn = this.container.querySelector('#rule-template-apply');

          if (!categorySelect || !templateSelect) return;

          const categories = typeof getTemplateCategories === 'function' ? getTemplateCategories() : [];
          categorySelect.innerHTML = '<option value="all">全部分类</option>';
          for (const cat of categories) {
            const opt = document.createElement('option');
            opt.value = cat.id;
            opt.textContent = `${cat.icon} ${cat.name}`;
            categorySelect.appendChild(opt);
          }

          const updateTemplateSelect = (categoryId) => {
            const templates = typeof getTemplatesByCategory === 'function' ? getTemplatesByCategory(categoryId) : [];
            templateSelect.innerHTML = '<option value="">选择模板...</option>';
            for (const tmpl of templates) {
              const opt = document.createElement('option');
              opt.value = tmpl.id;
              opt.textContent = `${tmpl.icon} ${tmpl.name}`;
              opt.title = tmpl.description;
              templateSelect.appendChild(opt);
            }
          };

          updateTemplateSelect('all');
          categorySelect.addEventListener('change', (e) => updateTemplateSelect(e.target.value));

          const applyTemplate = (templateId) => {
            if (!templateId) return;

            const template = typeof getTemplateById === 'function' ? getTemplateById(templateId) : null;
            if (!template || !template.rule) {
              showStatus('模板数据无效', 'error', 2000);
              return;
            }

            const toSelect = this.container.querySelector('#rule-to');
            if (toSelect && (template.action === 'direct' || template.action === 'block')) {
              toSelect.value = template.action;
            }

            const domainsInput = this.container.querySelector('#rule-domains');
            const ipsInput = this.container.querySelector('#rule-ips');
            const descInput = this.container.querySelector('#rule-description');

            const mergeLines = (base, extra) => {
              const out = [];
              const seen = new Set();
              for (const item of base) {
                if (!item) continue;
                if (seen.has(item)) continue;
                seen.add(item);
                out.push(item);
              }
              for (const item of extra) {
                if (!item) continue;
                if (seen.has(item)) continue;
                seen.add(item);
                out.push(item);
              }
              return out;
            };

            if (domainsInput) {
              const existing = (domainsInput.value || '').split('\n').map(s => s.trim()).filter(Boolean);
              const domains = Array.isArray(template.rule.domains) ? template.rule.domains : [];
              const merged = mergeLines(existing, domains);
              domainsInput.value = merged.join('\n');
            }

            if (ipsInput) {
              const existing = (ipsInput.value || '').split('\n').map(s => s.trim()).filter(Boolean);
              const ips = Array.isArray(template.rule.ips) ? template.rule.ips : [];
              const merged = mergeLines(existing, ips);
              ipsInput.value = merged.join('\n');
            }

            if (descInput) {
              const prev = String(descInput.value || '').trim();
              if (!prev) {
                descInput.value = `模板: ${template.name}`;
              } else if (prev.startsWith('模板:') && !prev.includes(template.name)) {
                descInput.value = `${prev} + ${template.name}`;
              }
            }

            showStatus(`已应用模板: ${template.name}`, 'success', 2000);
          };

          templateSelect.addEventListener('change', (e) => {
            applyTemplate(e.target.value);
          });

          if (applyBtn) {
            applyBtn.addEventListener('click', () => {
              if (!templateSelect.value) {
                showStatus('请先选择一个模板', 'error', 2000);
                return;
              }
              applyTemplate(templateSelect.value);
            });
          }
        }
      }

      async function initChainEditor() {
        if (chainEditorInitialized) return;

        const container = document.getElementById('panel-chain');
        if (!container) return;

        async function waitForProxyRestartError(prevRestartAt) {
          const timeoutMs = 20000;
          const scheduleWaitMs = 2000;
          const intervalMs = 500;

          const deadline = Date.now() + timeoutMs;
          const scheduleDeadline = Date.now() + scheduleWaitMs;

          let scheduled = false;
          while (Date.now() < deadline) {
            const status = await api.proxy.status();
            if (status && status.busy) {
              await sleep(intervalMs);
              continue;
            }

            const currentRestartAt = status && typeof status.lastRestartAt === 'string' ? status.lastRestartAt : '';
            if (!scheduled) {
              if (currentRestartAt && currentRestartAt !== prevRestartAt) {
                scheduled = true;
              } else if (Date.now() > scheduleDeadline) {
                return null;
              }
            }

            if (scheduled) {
              const restartError = status && typeof status.lastRestartError === 'string' ? status.lastRestartError : '';
              if (restartError) return restartError;
            }

            await sleep(intervalMs);
          }

          return null;
        }

        const chainApi = {
          get: async (path) => api.get(path),
          put: async (path, data) => api.put(path, data),
          post: async (path, data) => api.post(path, data)
        };

        chainListEditor = new ChainListEditor(container, chainApi);
        const current = getCurrentFRouter();
        chainListEditor.setFRouterId(current ? current.id : "");
        await chainListEditor.init();
        chainEditorInitialized = true;

        document.getElementById('chain-save')?.addEventListener('click', async () => {
          let prevRestartAt = '';
          try {
            const status = await api.proxy.status();
            prevRestartAt = status && typeof status.lastRestartAt === 'string' ? status.lastRestartAt : '';
          } catch {
            prevRestartAt = '';
          }

          const result = await chainListEditor.saveGraph();
          if (result.success) {
            showStatus('配置已保存', 'success');

            (async () => {
              try {
                const restartError = await waitForProxyRestartError(prevRestartAt);
                if (restartError) {
                  showStatus(`代理重启失败：${restartError}`, 'error', 6000);
                }
              } catch (err) {
                console.warn('Failed to check proxy restart error:', err);
              }
            })();
          } else {
            showStatus('保存失败: ' + result.error, 'error', 5000);
          }
        });

        document.getElementById('chain-reset')?.addEventListener('click', async () => {
          if (confirm('确定要重置为上次保存的配置吗？')) {
            await chainListEditor.loadGraph();
            showStatus('已重置', 'info');
          }
        });

        document.getElementById('chain-add-rule')?.addEventListener('click', () => {
          chainListEditor.addRule();
        });

        console.log('[ChainListEditor] 初始化完成');
      }

		      const loaders = {
		        "panel-home": () => loadHomePanel(),
		        panel1: loadFRouters,
		        panel2: loadConfigs,
		        "panel-nodes": () => {
		          startNodesPolling();
		          return loadNodes();
		        },
		        panel3: () => loadComponents(),
		        "panel-logs": () => {
		          ensureLogsTabs();
		          ensureKernelLogsPanel();
		          ensureAppLogsPanel();
		          startKernelLogsPolling();
		          startAppLogsPolling();
		          syncLogsTabUI();
		          return currentLogsTab === "app" ? loadAppLogs() : loadKernelLogs();
		        },
		        "panel-chain": initChainEditor,
	        "panel-settings": async () => {
	          await loadSystemProxySettings();
	        },
      };

      function openChainEditorPanel() {
        const target = "panel-chain";
        if (currentPanel === "panel-nodes") {
          stopNodesPolling();
        }
        if (currentPanel === "panel-logs") {
          stopKernelLogsPolling();
          stopAppLogsPolling();
        }
        if (target === currentPanel) {
          loaders[target]?.();
          return;
        }
        currentPanel = target;
        menu.querySelectorAll("button").forEach((btn) => btn.classList.remove("active"));
        // Chain Editor 作为 FRouter 面板的一部分：保持左侧高亮在 FRouter
        const activeBtn = menu.querySelector('button[data-target="panel1"]');
        if (activeBtn) activeBtn.classList.add("active");
        panels.forEach((panel) => {
          panel.classList.toggle("active", panel.id === target);
        });
        loaders[target]?.();
      }

      menu.addEventListener("click", (event) => {
        const button = event.target.closest("button[data-target]");
        if (!button) return;
        const target = button.dataset.target;
        if (target === currentPanel) return;

        const prevPanel = currentPanel;
        if (prevPanel === "panel-nodes" && target !== "panel-nodes") {
          stopNodesPolling();
        }
        if (prevPanel === "panel-logs" && target !== "panel-logs") {
          stopKernelLogsPolling();
          stopAppLogsPolling();
        }
        currentPanel = target;
        menu.querySelectorAll("button").forEach((btn) => btn.classList.remove("active"));
        button.classList.add("active");
        panels.forEach((panel) => {
          panel.classList.toggle("active", panel.id === target);
        });
        if (target === "panel-nodes") {
          startNodesPolling();
        }
        if (target === "panel-logs") {
          startKernelLogsPolling();
          startAppLogsPolling();
        }
        loaders[target]?.();
      });

      const nodeGrid = document.getElementById("node-grid");
      const nodeTabs = document.getElementById("node-tabs");
      const nodeAddButton = document.getElementById("node-add-button");
      const nodeModal = document.getElementById("node-modal");
      const nodeModalClose = document.getElementById("node-modal-close");
	      const nodeModalReset = document.getElementById("node-modal-reset");
		      const nodeModalBackdrop = nodeModal ? nodeModal.querySelector(".modal-backdrop") : null;
		      const nodeForm = document.getElementById("node-form");
		      const chainRouteSelect = document.getElementById("chain-route-select");
	      const nodeRefreshBtn = document.getElementById("node-refresh");
	      nodeRefreshBtn.addEventListener("click", () => loadFRouters({ notify: true }));
	      document.getElementById("config-refresh").addEventListener("click", () => loadConfigs({ notify: true }));
	      document.getElementById("component-refresh").addEventListener("click", () => loadComponents({ notify: true }));

	      const nodesTable = document.getElementById("nodes-table");
	      if (nodesTable) {
	        nodesTable.addEventListener("click", async (event) => {
	          const button = event.target.closest("button[data-action]");
	          if (!button) return;
	          const row = button.closest("tr[data-id]");
	          if (!row) return;
	          const id = row.dataset.id;
	          if (!id) return;

	          const action = button.dataset.action;
	          try {
            if (action === "ping-node") {
              await api.post(`/nodes/${id}/ping`, {});
              showStatus("节点延迟任务已提交", "info");
            } else if (action === "speedtest-node") {
              await api.post(`/nodes/${id}/speedtest`, {});
              showStatus("节点测速任务已提交", "info");
            } else if (action === "edit-node") {
              const node = Array.isArray(nodesCache) ? nodesCache.find((item) => item.id === id) : null;
              if (!node) {
                showStatus("节点未找到", "error", 4000);
                return;
              }
              openNodesModal(node);
              return;
            }

            setTimeout(() => {
              if (currentPanel === "panel-nodes") {
                loadNodes();
	              }
	            }, 1200);
	          } catch (err) {
	            showStatus(`节点操作失败：${err.message}`, "error", 6000);
	          }
	        });
	      }

	      const nodesBulkPingButton = document.getElementById("nodes-bulk-ping");
	      if (nodesBulkPingButton) {
	        nodesBulkPingButton.addEventListener("click", async () => {
	          if (!Array.isArray(nodesCache) || nodesCache.length === 0) {
	            showStatus("暂无节点", "error");
	            return;
	          }
	          try {
	            await api.post("/nodes/bulk/ping", {});
	            showStatus("批量延迟任务已排队", "info");
	            setTimeout(() => currentPanel === "panel-nodes" && loadNodes(), 1200);
	            setTimeout(() => currentPanel === "panel-nodes" && loadNodes(), 3000);
	          } catch (err) {
	            showStatus(`批量测延迟失败：${err.message}`, "error", 6000);
	          }
	        });
	      }

	      const nodesBulkSpeedButton = document.getElementById("nodes-bulk-speed");
	      if (nodesBulkSpeedButton) {
	        nodesBulkSpeedButton.addEventListener("click", async () => {
	          if (!Array.isArray(nodesCache) || nodesCache.length === 0) {
	            showStatus("暂无节点", "error");
	            return;
	          }
	          try {
	            await api.post("/nodes/bulk/speedtest", {});
	            showStatus("批量测速任务已排队", "info");
	            setTimeout(() => currentPanel === "panel-nodes" && loadNodes(), 1200);
	            setTimeout(() => currentPanel === "panel-nodes" && loadNodes(), 5000);
	          } catch (err) {
	            showStatus(`批量测速失败：${err.message}`, "error", 6000);
	          }
	        });
	      }

		      function ensureFRouterContextMenu() {
		        let menu = document.getElementById("frouter-context-menu");
		        if (menu) return menu;

	        menu = document.createElement("div");
	        menu.id = "frouter-context-menu";
	        // 复用 chain-editor.css 的右键菜单样式
	        menu.className = "slot-context-menu";
	        menu.innerHTML = `
	          <div class="slot-context-menu-item" data-action="open-chain">链路编辑</div>
	        `;
	        document.body.appendChild(menu);

	        menu.addEventListener("click", (e) => {
	          const item = e.target.closest(".slot-context-menu-item[data-action]");
	          if (!item) return;
	          menu.classList.remove("visible");

	          const action = item.dataset.action;
	          const frouterId = menu.dataset.frouterId || "";
	          if (action === "open-chain") {
	            if (frouterId) setCurrentFRouter(frouterId, { notify: false });
	            openChainEditorPanel();
	          }
	        });

	        document.addEventListener("click", () => menu.classList.remove("visible"));
	        window.addEventListener("blur", () => menu.classList.remove("visible"));
	        return menu;
	      }

      document.getElementById("chain-back")?.addEventListener("click", () => {
        const btn = menu.querySelector('button[data-target="panel1"]');
        if (btn) {
          btn.click();
          return;
        }
        currentPanel = "panel1";
        panels.forEach((panel) => {
          panel.classList.toggle("active", panel.id === "panel1");
        });
        loaders.panel1?.();
      });

      // TUN status click handler
      const tunStatusValue = document.getElementById("tun-status-value");
      if (tunStatusValue) {
        tunStatusValue.addEventListener("click", showTUNStatusDialog);
      }

	      // TUN toggle handler
	      const tunToggle = document.getElementById("tun-toggle");
	      if (tunToggle) {
	        tunToggle.addEventListener("change", (event) => {
	          updateTUNSetting(event.target.checked);
	        });
	      }

	      // Engine select handler
	      const engineSelect = document.getElementById("engine-select");
	      if (engineSelect) {
	        engineSelect.addEventListener("change", (event) => {
	          updateEngineSetting(event.target.value);
	        });
	      }

	      const systemProxyIgnoreInput = document.getElementById("system-proxy-ignore");
	      const systemProxySaveButton = document.getElementById("system-proxy-save");
	      const systemProxyResetButton = document.getElementById("system-proxy-reset");
	      const proxyToggleButton = document.getElementById("proxy-toggle");
	      if (proxyToggleButton) {
        proxyToggleButton.addEventListener("click", handleProxyToggle);
      }

      if (chainRouteSelect) {
        chainRouteSelect.addEventListener("change", (event) => {
          setCurrentFRouter(event.target.value, { notify: true });
        });
      }

      function openNodeModal() {
        if (!nodeModal) return;
        nodeModal.classList.add("open");
      }

      function closeNodeModal() {
        if (!nodeModal) return;
        nodeModal.classList.remove("open");
      }

      if (nodeAddButton) {
        nodeAddButton.addEventListener("click", openNodeModal);
      }
      if (nodeModalClose) {
        nodeModalClose.addEventListener("click", closeNodeModal);
      }
      if (nodeModalBackdrop) {
        nodeModalBackdrop.addEventListener("click", closeNodeModal);
      }
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && nodeModal?.classList.contains("open")) {
          closeNodeModal();
        }
      });
      if (nodeModalReset && nodeForm) {
        nodeModalReset.addEventListener("click", () => {
          nodeForm.reset();
        });
      }

      // Handle protocol and network-specific field visibility
      const protocolSelect = document.getElementById("protocol-select");
      const networkSelect = document.getElementById("network-select");
      const tlsSelect = nodeForm?.querySelector('select[name="tls"]');

      function updateFieldVisibility() {
        if (!protocolSelect) return;

        const protocol = protocolSelect.value;
        const network = networkSelect?.value || "tcp";
        const tls = tlsSelect?.value || "";

        // Hide all protocol-specific fields first
        const ssFields = document.getElementById("ss-fields");
        const vmessFields = document.getElementById("vmess-fields");
        const trojanFields = document.getElementById("trojan-fields");
        const proxyFields = document.getElementById("proxy-fields");

        if (ssFields) ssFields.style.display = "none";
        if (vmessFields) vmessFields.style.display = "none";
        if (trojanFields) trojanFields.style.display = "none";
        if (proxyFields) proxyFields.style.display = "none";

        // Show relevant protocol fields
        if (protocol === "shadowsocks" && ssFields) {
          ssFields.style.display = "grid";
        } else if ((protocol === "vmess" || protocol === "vless") && vmessFields) {
          vmessFields.style.display = "grid";
        } else if (protocol === "trojan" && trojanFields) {
          trojanFields.style.display = "block";
        } else if ((protocol === "http" || protocol === "socks5") && proxyFields) {
          proxyFields.style.display = "grid";
        }

        // Hide all network-specific fields first
        const wsFields = document.getElementById("ws-fields");
        const h2Fields = document.getElementById("h2-fields");
        const grpcFields = document.getElementById("grpc-fields");

        if (wsFields) wsFields.style.display = "none";
        if (h2Fields) h2Fields.style.display = "none";
        if (grpcFields) grpcFields.style.display = "none";

        // Show relevant network fields
        if (network === "ws" && wsFields) {
          wsFields.style.display = "grid";
        } else if (network === "h2" && h2Fields) {
          h2Fields.style.display = "grid";
        } else if (network === "grpc" && grpcFields) {
          grpcFields.style.display = "block";
        }

        // Show/hide TLS fields
        const tlsFields = document.getElementById("tls-fields");
        if (tlsFields) {
          tlsFields.style.display = (tls && tls !== "") ? "grid" : "none";
        }
      }

      if (protocolSelect) {
        protocolSelect.addEventListener("change", updateFieldVisibility);
      }
      if (networkSelect) {
        networkSelect.addEventListener("change", updateFieldVisibility);
      }
      if (tlsSelect) {
        tlsSelect.addEventListener("change", updateFieldVisibility);
      }

      // Handle advanced settings toggles
      const enableNetworkCheckbox = document.getElementById("enable-network");
      const enableTlsCheckbox = document.getElementById("enable-tls");
      const networkSettings = document.getElementById("network-settings");
      const tlsSettings = document.getElementById("tls-settings");

      if (enableNetworkCheckbox && networkSettings) {
        enableNetworkCheckbox.addEventListener("change", (e) => {
          networkSettings.style.display = e.target.checked ? "grid" : "none";
          if (e.target.checked) {
            updateFieldVisibility();
          }
        });
      }

      if (enableTlsCheckbox && tlsSettings) {
        enableTlsCheckbox.addEventListener("change", (e) => {
          tlsSettings.style.display = e.target.checked ? "grid" : "none";
        });
      }

      if (nodeForm) {
        nodeForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          const form = event.target;
          const frouterName = form.name.value.trim();
          const tags = parseList(form.tags.value);

		          if (!frouterName) {
		            showStatus("请填写 FRouter 名称", "error");
		            return;
		          }

		          try {
		            await api.post("/frouters", { name: frouterName, tags });
		            form.reset();
		            showStatus("FRouter 添加成功", "success");
		            closeNodeModal();
		            await loadFRouters();
		          } catch (err) {
		            showStatus(`添加 FRouter 失败：${err.message}`, "error", 6000);
          }
        });
      }

      const nodesAddButton = document.getElementById("nodes-add-button");
      const nodesModal = document.getElementById("nodes-modal");
      const nodesModalClose = document.getElementById("nodes-modal-close");
      const nodesModalReset = document.getElementById("nodes-modal-reset");
      const nodesModalBackdrop = nodesModal ? nodesModal.querySelector(".modal-backdrop") : null;
      const nodesForm = document.getElementById("nodes-form");
      const nodesModalTitle = document.getElementById("nodes-modal-title");
      const nodesSubmitButton = nodesForm ? nodesForm.querySelector('button[type="submit"]') : null;
      const nodesProtocolSelect = document.getElementById("nodes-protocol-select");
      const nodesNetworkSelect = document.getElementById("nodes-network-select");
      const nodesTLSSelect = document.getElementById("nodes-tls-select");
      let editingNode = null;

      function setNodesModalMode(isEdit) {
        if (nodesModalTitle) {
          nodesModalTitle.textContent = isEdit ? "编辑节点" : "添加节点";
        }
        if (nodesSubmitButton) {
          nodesSubmitButton.textContent = isEdit ? "保存修改" : "创建节点";
        }
      }

      function updateNodesFieldVisibility() {
        if (!nodesForm) return;
        const protocol = nodesProtocolSelect?.value || "";
        const network = nodesNetworkSelect?.value || "tcp";
        const tls = nodesTLSSelect?.value || "";

        const ssFields = document.getElementById("nodes-ss-fields");
        const vmessFields = document.getElementById("nodes-vmess-fields");
        const trojanFields = document.getElementById("nodes-trojan-fields");
        if (ssFields) ssFields.style.display = "none";
        if (vmessFields) vmessFields.style.display = "none";
        if (trojanFields) trojanFields.style.display = "none";

        if (protocol === "shadowsocks" && ssFields) {
          ssFields.style.display = "grid";
        } else if ((protocol === "vmess" || protocol === "vless") && vmessFields) {
          vmessFields.style.display = "grid";
        } else if (protocol === "trojan" && trojanFields) {
          trojanFields.style.display = "block";
        }

        const wsFields = document.getElementById("nodes-ws-fields");
        const httpFields = document.getElementById("nodes-http-fields");
        const grpcFields = document.getElementById("nodes-grpc-fields");
        if (wsFields) wsFields.style.display = "none";
        if (httpFields) httpFields.style.display = "none";
        if (grpcFields) grpcFields.style.display = "none";

        if (network === "ws" && wsFields) {
          wsFields.style.display = "grid";
        } else if ((network === "http" || network === "h2") && httpFields) {
          httpFields.style.display = "grid";
        } else if (network === "grpc" && grpcFields) {
          grpcFields.style.display = "block";
        }

        const tlsFields = document.getElementById("nodes-tls-fields");
        if (tlsFields) {
          tlsFields.style.display = tls ? "grid" : "none";
        }
      }

      function fillNodesForm(node) {
        if (!nodesForm || !node) return;
        nodesForm.name.value = node.name || "";
        nodesForm.address.value = node.address || "";
        nodesForm.port.value = node.port ? String(node.port) : "";
        nodesForm.protocol.value = node.protocol || "shadowsocks";
        nodesForm.tags.value = Array.isArray(node.tags) ? node.tags.join(",") : "";

        const sec = node.security || {};
        nodesForm.ss_method.value = sec.method || "aes-256-gcm";
        nodesForm.ss_password.value = sec.password || "";
        nodesForm.vmess_uuid.value = sec.uuid || "";
        nodesForm.vmess_alterid.value = Number.isFinite(sec.alterId) ? String(sec.alterId) : "0";
        nodesForm.vmess_security.value = sec.encryption || sec.method || "auto";
        nodesForm.vless_flow.value = sec.flow || "";
        nodesForm.trojan_password.value = sec.password || "";

        const transportType = node.transport?.type || "tcp";
        nodesForm.network.value = transportType;
        nodesForm.ws_path.value = node.transport?.path || "";
        nodesForm.ws_host.value = node.transport?.host || "";
        nodesForm.h2_path.value = node.transport?.path || "";
        nodesForm.h2_host.value = node.transport?.host || "";
        nodesForm.grpc_service.value = node.transport?.serviceName || "";

        const tlsEnabled = node.tls && node.tls.enabled;
        nodesForm.tls.value = tlsEnabled ? (node.tls.type || "tls") : "";
        nodesForm.tls_sni.value = node.tls?.serverName || "";
        nodesForm.tls_fingerprint.value = node.tls?.fingerprint || "";
        nodesForm.tls_insecure.value = node.tls?.insecure ? "true" : "false";

        updateNodesFieldVisibility();
      }

      function setNodesReadonlyForSubscription(enabled) {
        if (!nodesForm) return;
        const lockedNames = [
          "address",
          "port",
          "protocol",
          "ss_method",
          "ss_password",
          "vmess_uuid",
          "vmess_alterid",
          "vmess_security",
          "vless_flow",
          "trojan_password",
          "network",
          "ws_path",
          "ws_host",
          "h2_path",
          "h2_host",
          "grpc_service",
          "tls",
          "tls_sni",
          "tls_fingerprint",
          "tls_insecure",
        ];
        for (const name of lockedNames) {
          const el = nodesForm.querySelector(`[name="${name}"]`);
          if (!el) continue;
          el.disabled = Boolean(enabled);
        }
      }

      function openNodesModal(node = null) {
        if (!nodesModal) return;
        nodesModal.classList.add("open");
        editingNode = node;
        if (nodesForm) nodesForm.reset();
        const isEdit = Boolean(editingNode);
        setNodesModalMode(isEdit);
        const shareLinkRow = document.getElementById("nodes-sharelink-row");
        if (shareLinkRow) {
          shareLinkRow.style.display = isEdit ? "none" : "block";
        }
        if (editingNode) {
          fillNodesForm(editingNode);
          const subscription = Boolean(editingNode.sourceConfigId);
          setNodesReadonlyForSubscription(subscription);
          if (subscription) {
            showStatus("订阅节点仅支持修改名称/标签", "info", 3200);
          }
        } else {
          setNodesReadonlyForSubscription(false);
          updateNodesFieldVisibility();
        }
      }

      function closeNodesModal() {
        if (!nodesModal) return;
        nodesModal.classList.remove("open");
        editingNode = null;
      }

      if (nodesAddButton) {
        nodesAddButton.addEventListener("click", () => openNodesModal());
      }
      if (nodesModalClose) {
        nodesModalClose.addEventListener("click", closeNodesModal);
      }
      if (nodesModalBackdrop) {
        nodesModalBackdrop.addEventListener("click", closeNodesModal);
      }
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && nodesModal?.classList.contains("open")) {
          closeNodesModal();
        }
      });
      if (nodesModalReset && nodesForm) {
        nodesModalReset.addEventListener("click", () => {
          if (editingNode) {
            fillNodesForm(editingNode);
            return;
          }
          nodesForm.reset();
          updateNodesFieldVisibility();
        });
      }

      if (nodesProtocolSelect) {
        nodesProtocolSelect.addEventListener("change", updateNodesFieldVisibility);
      }
      if (nodesNetworkSelect) {
        nodesNetworkSelect.addEventListener("change", updateNodesFieldVisibility);
      }
      if (nodesTLSSelect) {
        nodesTLSSelect.addEventListener("change", updateNodesFieldVisibility);
      }

      if (nodesForm) {
        nodesForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          const form = event.target;
          const isEdit = Boolean(editingNode && editingNode.id);
          const isSubscriptionEdit = Boolean(isEdit && editingNode.sourceConfigId);
          const shareLink = (form.shareLink?.value || "").trim();
          const tags = parseList(form.tags.value);

          if (!isEdit && shareLink) {
            const payload = { shareLink };
            if (tags.length) {
              payload.tags = tags;
            }
            try {
              const resp = await api.post("/nodes/from-link", payload);
              const count = Array.isArray(resp?.nodes) ? resp.nodes.length : 0;
              showStatus(count > 1 ? `已导入 ${count} 个节点` : "节点已添加", "success");
              form.reset();
              closeNodesModal();
              await loadNodes();
            } catch (err) {
              showStatus(`导入节点失败：${err.message}`, "error", 6000);
            }
            return;
          }

          if (isSubscriptionEdit) {
            const name = form.name.value.trim();
            if (!name) {
              showStatus("请填写节点名称", "error", 5000);
              return;
            }
            try {
              await api.put(`/nodes/${editingNode.id}/meta`, { name, tags });
              showStatus("节点已更新", "success");
              closeNodesModal();
              await loadNodes();
            } catch (err) {
              showStatus(`更新节点失败：${err.message}`, "error", 6000);
            }
            return;
          }

          const protocol = form.protocol.value;
          const payload = {
            name: form.name.value.trim(),
            address: form.address.value.trim(),
            port: parseNumber(form.port.value),
            protocol,
          };
          if (tags.length) {
            payload.tags = tags;
          }
          if (!payload.name) {
            showStatus("请填写节点名称", "error", 5000);
            return;
          }
          if (!payload.address) {
            showStatus("请填写服务器地址", "error", 5000);
            return;
          }
          if (!payload.port || payload.port <= 0) {
            showStatus("请填写有效端口", "error", 5000);
            return;
          }

          const security = {};
          if (protocol === "shadowsocks") {
            security.method = form.ss_method.value.trim();
            security.password = form.ss_password.value.trim();
            if (!security.method || !security.password) {
              showStatus("Shadowsocks 需要加密方式和密码", "error", 5000);
              return;
            }
          } else if (protocol === "vmess" || protocol === "vless") {
            security.uuid = form.vmess_uuid.value.trim();
            security.alterId = parseNumber(form.vmess_alterid.value);
            const enc = form.vmess_security.value.trim();
            if (enc) {
              security.encryption = enc;
              security.method = enc;
            }
            const flow = form.vless_flow.value.trim();
            if (flow) security.flow = flow;
            if (!security.uuid) {
              showStatus("VMess/VLESS 需要填写 UUID", "error", 5000);
              return;
            }
          } else if (protocol === "trojan") {
            security.password = form.trojan_password.value.trim();
            if (!security.password) {
              showStatus("Trojan 需要填写密码", "error", 5000);
              return;
            }
          }
          if (Object.keys(security).length > 0) {
            payload.security = security;
          }

          const network = form.network.value || "tcp";
          if (network && network !== "tcp") {
            const transport = { type: network };
            if (network === "ws") {
              transport.path = form.ws_path.value.trim();
              transport.host = form.ws_host.value.trim();
            } else if (network === "http" || network === "h2") {
              transport.path = form.h2_path.value.trim();
              transport.host = form.h2_host.value.trim();
            } else if (network === "grpc") {
              transport.serviceName = form.grpc_service.value.trim();
            }
            payload.transport = transport;
          }

          const tlsType = form.tls.value;
          if (tlsType) {
            const tls = {
              enabled: true,
              type: tlsType,
              insecure: form.tls_insecure.value === "true",
            };
            const sni = form.tls_sni.value.trim();
            const fp = form.tls_fingerprint.value.trim();
            if (sni) tls.serverName = sni;
            if (fp) tls.fingerprint = fp;
            payload.tls = tls;
          }

          try {
            if (editingNode && editingNode.id) {
              await api.put(`/nodes/${editingNode.id}`, payload);
              showStatus("节点已更新", "success");
            } else {
              await api.post("/nodes", payload);
              showStatus("节点已添加", "success");
              form.reset();
            }
            closeNodesModal();
            await loadNodes();
          } catch (err) {
            showStatus(`${editingNode ? "更新" : "添加"}节点失败：${err.message}`, "error", 6000);
          }
        });
      }

      if (nodeGrid) {
        nodeGrid.addEventListener("click", async (event) => {
          const row = event.target.closest(".node-row[data-id]");
          if (!row) return;
	          const id = row.dataset.id;
          const actionTarget = event.target.closest("[data-action]");
          const action = actionTarget ? actionTarget.dataset.action : null;
          if (!action) {
            setCurrentFRouter(id, { notify: false });
            await applyFRouterSelection(id, { notify: true });
            return;
          }
          try {
            if (action === "ping-route") {
              await api.post(`/frouters/${id}/ping`);
              showStatus("延迟任务已排队", "info");
              await loadFRouters();
            } else if (action === "speed-route") {
              await api.post(`/frouters/${id}/speedtest`);
              showStatus("测速任务已排队", "info");
              await loadFRouters();
            }
          } catch (err) {
            showStatus(`操作失败：${err.message}`, "error", 6000);
	          }
	        });

	        nodeGrid.addEventListener("dblclick", (event) => {
	          const row = event.target.closest(".node-row[data-id]");
	          if (!row) return;
	          if (event.target.closest("[data-action]")) return;
	          setCurrentFRouter(row.dataset.id, { notify: false });
	          openChainEditorPanel();
	        });

	        nodeGrid.addEventListener("contextmenu", (event) => {
	          const row = event.target.closest(".node-row[data-id]");
	          if (!row) return;
	          event.preventDefault();

	          const id = row.dataset.id;
	          setCurrentFRouter(id, { notify: false, reloadGraph: false });

	          const menu = ensureFRouterContextMenu();
	          menu.dataset.frouterId = id;

	          const maxLeft = Math.max(0, window.innerWidth - 200);
	          const maxTop = Math.max(0, window.innerHeight - 120);
	          menu.style.left = `${Math.min(event.clientX, maxLeft)}px`;
	          menu.style.top = `${Math.min(event.clientY, maxTop)}px`;
	          menu.classList.add("visible");
	        });
	      }

      if (nodeTabs) {
        nodeTabs.addEventListener("click", (event) => {
          const button = event.target.closest(".node-tab[data-tag]");
          if (!button) return;
          const tag = button.dataset.tag;
          if (tag === currentFRouterTab) return;
          currentFRouterTab = tag;
          nodeTabs.querySelectorAll(".node-tab").forEach((tab) => tab.classList.remove("active"));
          button.classList.add("active");
          renderFRouters(froutersCache, currentFRouterId);
        });
      }

      const configModal = document.getElementById("config-modal");
      const configAddButton = document.getElementById("config-add-button");
      const configModalClose = document.getElementById("config-modal-close");
      const configModalBackdrop = configModal?.querySelector(".modal-backdrop");
      const configModalReset = document.getElementById("config-modal-reset");
      const configForm = document.getElementById("config-form");
      const configModalTitle = document.getElementById("config-modal-title");
      const configSubmitButton = configForm ? configForm.querySelector('button[type="submit"]') : null;
      let editingConfig = null;

      function durationToMinutes(value) {
        if (!value) return 0;
        if (typeof value === "number") {
          if (!Number.isFinite(value) || value <= 0) return 0;
          return Math.round(value / 60000000000);
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            const num = Number(value);
            return Number.isFinite(num) ? Math.round(num / 60000000000) : 0;
          }
          let hours = 0;
          let minutes = 0;
          const hMatch = value.match(/(\\d+)h/);
          const mMatch = value.match(/(\\d+)m/);
          if (hMatch) hours = parseInt(hMatch[1], 10);
          if (mMatch) minutes = parseInt(mMatch[1], 10);
          return hours * 60 + minutes;
        }
        return 0;
      }

      function setConfigModalMode(isEdit) {
        if (configModalTitle) {
          configModalTitle.textContent = isEdit ? "编辑订阅" : "添加订阅";
        }
        if (configSubmitButton) {
          configSubmitButton.textContent = isEdit ? "保存修改" : "保存订阅";
        }
      }

      function fillConfigForm(cfg) {
        if (!configForm || !cfg) return;
        configForm.name.value = cfg.name || "";
        configForm.sourceUrl.value = cfg.sourceUrl || "";
        configForm.payload.value = cfg.payload || "";
        const minutes = durationToMinutes(cfg.autoUpdateInterval);
        configForm.autoUpdateInterval.value = Number.isFinite(minutes) ? String(minutes) : "0";
      }

      function openConfigModal(config = null) {
        if (!configModal) return;
        configModal.classList.add("open");
        editingConfig = config || null;
        if (configForm) configForm.reset();
        setConfigModalMode(Boolean(editingConfig));
        if (editingConfig) {
          fillConfigForm(editingConfig);
        }
      }

      function closeConfigModal() {
        if (!configModal) return;
        configModal.classList.remove("open");
        editingConfig = null;
      }

      if (configAddButton) {
        configAddButton.addEventListener("click", openConfigModal);
      }
      if (configModalClose) {
        configModalClose.addEventListener("click", closeConfigModal);
      }
      if (configModalBackdrop) {
        configModalBackdrop.addEventListener("click", closeConfigModal);
      }
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && configModal?.classList.contains("open")) {
          closeConfigModal();
        }
      });
      if (configModalReset && configForm) {
        configModalReset.addEventListener("click", () => {
          if (editingConfig) {
            fillConfigForm(editingConfig);
            return;
          }
          configForm.reset();
        });
      }

      if (configForm) {
        configForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          const form = event.target;
          const isEdit = Boolean(editingConfig && editingConfig.id);
          const typedPayload = (form.payload.value || "").trim();
          const sourceUrlInput = form.sourceUrl.value.trim();
          const sourceUrl = sourceUrlInput || (isEdit ? (editingConfig?.sourceUrl || "") : "");
          const payload = {
            name: form.name.value.trim() || (isEdit ? (editingConfig?.name || "") : ""),
            format: "subscription",
            sourceUrl,
            payload: typedPayload || (isEdit ? (editingConfig?.payload || "") : ""),
            autoUpdateIntervalMinutes: parseNumber(form.autoUpdateInterval.value),
          };
          if (!payload.name) {
            showStatus("请填写名称", "error", 5000);
            return;
          }
          if (!payload.sourceUrl) {
            showStatus("请填写源/订阅链接", "error", 5000);
            return;
          }
          try {
            if (isEdit) {
              await api.put(`/configs/${editingConfig.id}`, payload);
              showStatus("配置已更新", "success");
            } else {
              await api.post("/configs/import", payload);
              form.reset();
              showStatus("配置添加成功", "success");
            }
            closeConfigModal();
            await Promise.all([loadConfigs(), loadFRouters(), loadNodes()]);
          } catch (err) {
            showStatus(`${isEdit ? "更新" : "添加"}配置失败：${err.message}`, "error", 6000);
          }
        });
      }

      function getSelectedFRouterIds() {
        if (!nodeGrid) return [];
        return Array.from(nodeGrid.querySelectorAll(".node-row[data-id]"))
          .map((card) => card.dataset.id)
          .filter(Boolean);
      }

      async function runBulkSpeedTest({ notify = true } = {}) {
        const ids = getSelectedFRouterIds();
        if (ids.length === 0) {
	          if (notify) {
	            showStatus("暂无可测试 FRouter", "error");
	          }
          return;
        }
        try {
          await api.post("/frouters/reset-speed", { ids });
          await loadFRouters();
          for (const id of ids) {
            await api.post(`/frouters/${id}/speedtest`);
          }
          if (notify) {
            showStatus("批量测速任务已排队", "info");
          }
          await loadFRouters();
        } catch (err) {
          if (notify) {
            showStatus(`批量测速失败：${err.message}`, "error", 6000);
          } else {
            console.error("自动测速失败:", err);
          }
        }
      }

      document.getElementById("node-bulk-ping").addEventListener("click", async () => {
        const ids = getSelectedFRouterIds();
        if (ids.length === 0) {
	          showStatus("暂无可测试 FRouter", "error");
	          return;
	        }
        try {
          await api.post("/frouters/bulk/ping", { ids });
          showStatus("批量延迟任务已排队", "info");
          await loadFRouters();
        } catch (err) {
          showStatus(`批量延迟失败：${err.message}`, "error", 6000);
        }
      });

      document.getElementById("node-bulk-speed").addEventListener("click", async () => {
        await runBulkSpeedTest({ notify: true });
      });

      document.getElementById("config-table").addEventListener("click", async (event) => {
        const button = event.target.closest("button[data-action]");
        if (!button) return;
        const tr = button.closest("tr[data-id]");
        if (!tr) return;
        const id = tr.dataset.id;
        const action = button.dataset.action;
        try {
	          if (action === "edit-config") {
	            const cfg = Array.isArray(configsCache) ? configsCache.find((item) => item.id === id) : null;
	            if (!cfg) {
	              showStatus("配置未找到", "error", 4000);
	              return;
	            }
	            openConfigModal(cfg);
	          } else if (action === "pull-nodes") {
	            await api.post(`/configs/${id}/pull-nodes`);
	            showStatus("订阅节点已同步", "success");
	            await Promise.all([loadConfigs(), loadFRouters(), loadNodes()]);
	          } else if (action === "delete-config") {
            if (!confirm("确认删除该配置？")) return;
            await api.delete(`/configs/${id}`);
            showStatus("配置已删除", "success");
            await Promise.all([loadConfigs(), loadFRouters(), loadNodes()]);
          }
        } catch (err) {
          showStatus(`操作失败：${err.message}`, "error", 6000);
        }
      });

      if (systemProxySaveButton) {
        systemProxySaveButton.addEventListener("click", async () => {
          try {
            systemProxySaveButton.disabled = true;
            const payload = {
              enabled: Boolean(systemProxySettings && systemProxySettings.enabled),
              ignoreHosts: collectIgnoreHosts(),
            };
            const response = await api.put("/settings/system-proxy", payload);
            const data = response && response.settings ? response.settings : response;
            systemProxySettings = {
              enabled: Boolean(data.enabled),
              ignoreHosts: Array.isArray(data.ignoreHosts) ? data.ignoreHosts : [...SYSTEM_PROXY_DEFAULTS],
            };
            renderSystemProxy(systemProxySettings);
            updateCoreUI(coreStatus);
            const msg = response && response.message ? response.message : "系统代理设置已保存";
            showStatus(msg, response && response.message ? "info" : "success");
          } catch (err) {
            showStatus(`保存系统代理失败：${err.message}`, "error", 6000);
          } finally {
            systemProxySaveButton.disabled = false;
          }
        });
      }

      if (systemProxyResetButton) {
        systemProxyResetButton.addEventListener("click", () => {
          systemProxySettings = {
            ...systemProxySettings,
            ignoreHosts: [...SYSTEM_PROXY_DEFAULTS],
          };
          renderSystemProxy(systemProxySettings);
          updateCoreUI(coreStatus);
        });
      }

      // TUN 设置按钮事件
      const tunSetupBtn = document.getElementById("tun-setup-btn");

      if (tunSetupBtn) {
        tunSetupBtn.addEventListener("click", () => {
          setupTUN();
        });
      }

      renderSystemProxy(systemProxySettings);

      // 设置标签切换
      const settingsNavItems = document.querySelectorAll(".settings-nav-item");
      settingsNavItems.forEach((item) => {
        item.addEventListener("click", () => {
          const tab = item.dataset.settingsTab;

          // 更新导航项状态
          settingsNavItems.forEach((navItem) => navItem.classList.remove("active"));
          item.classList.add("active");

          // 更新内容显示
          document.querySelectorAll(".settings-content").forEach((content) => {
            content.classList.remove("active");
            content.style.display = "none";
          });

          const targetContent = document.getElementById(`settings-${tab}`);
          if (targetContent) {
            targetContent.classList.add("active");
            targetContent.style.display = "block";
          }
        });
      });

      // ===== 动态设置系统初始化 =====
      const settingsManager = new SettingsManager(SETTINGS_SCHEMA);
      const settingsRenderer = new SettingsRenderer(settingsManager);

      // 类别 ID 映射到 DOM 容器 ID
      const categoryToContainerId = {
        general: 'settings-general',
        proxy: 'settings-proxy',
        tun: 'settings-network',
        singbox: 'settings-singbox',
        advanced: 'settings-advanced'
      };

      // 渲染所有设置类别
      function renderAllSettings() {
        for (const [categoryId, containerId] of Object.entries(categoryToContainerId)) {
          const container = document.getElementById(containerId);
          if (container) {
            container.innerHTML = settingsRenderer.renderCategory(categoryId);
            settingsRenderer.bindEvents(container);
          }
        }

        // TUN：配置按钮（renderAllSettings 会重建 DOM）
        const tunSetupBtn = document.getElementById("tun-setup-btn");
        if (tunSetupBtn) {
          tunSetupBtn.addEventListener("click", () => {
            setupTUN();
          });
        }

        // 重新渲染后刷新一次 TUN UI（避免状态面板显示为默认值）
        if (tunStatusCache) {
          updateTUNUI(tunStatusCache);
        }

        // 特殊处理：主题选择器事件绑定
        const themeSelect = document.querySelector('[data-key="theme"]');
        if (themeSelect) {
          themeSelect.addEventListener('change', (e) => {
            switchTheme(e.target.value);
          });
          // 设置当前主题
          const currentFile = window.location.pathname.split('/').pop();
          const currentTheme = currentFile.includes('light') ? 'light' : 'dark';
          themeSelect.value = currentTheme;
        }
      }

      // 初始化渲染
      renderAllSettings();

      // 导入设置按钮
      const settingsImportBtn = document.getElementById('settings-import-btn');
      if (settingsImportBtn) {
        settingsImportBtn.addEventListener('click', () => {
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = '.json';
          input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            try {
              const text = await file.text();
              const result = settingsManager.importJSON(text);
              if (result.success) {
                showStatus(`导入成功：${result.imported} 项设置`, 'success');
                renderAllSettings();
              } else {
                showStatus(`导入失败：${result.error}`, 'error', 5000);
              }
            } catch (err) {
              showStatus(`读取文件失败：${err.message}`, 'error', 5000);
            }
          };
          input.click();
        });
      }

      // 导出设置按钮
      const settingsExportBtn = document.getElementById('settings-export-btn');
      if (settingsExportBtn) {
        settingsExportBtn.addEventListener('click', () => {
          const json = settingsManager.exportJSON();
          const blob = new Blob([json], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `vea-settings-${new Date().toISOString().split('T')[0]}.json`;
          a.click();
          URL.revokeObjectURL(url);
          showStatus('设置已导出', 'success');
        });
      }

      // 恢复默认按钮
      const settingsResetBtn = document.getElementById('settings-reset-btn');
      if (settingsResetBtn) {
        settingsResetBtn.addEventListener('click', () => {
          if (!confirm('确认恢复所有设置为默认值？')) return;
          settingsManager.resetToDefaults();
          renderAllSettings();
          showStatus('已恢复默认设置', 'success');
        });
      }

      // ===== 系统代理端口（ProxyConfig.inboundPort）联动 =====
      // 注意：
      // - sing-box / mihomo(clash): mixed 端口同时提供 HTTP + SOCKS
      let proxyPortApplyTimeout = null;

      async function syncProxyPortFromBackend() {
        try {
          const cfg = await api.get("/proxy/config");
          const port = cfg && typeof cfg.inboundPort === "number" ? cfg.inboundPort : 0;
          if (port > 0) {
            settingsManager.values["proxy.port"] = port; // 直接写入，避免触发监听器
          }
        } catch (err) {
          console.warn("[Settings] 同步代理端口失败:", err.message);
        }
      }

      async function applyProxyPortSetting(port) {
        const normalized = parseInt(String(port), 10);
        if (!Number.isFinite(normalized) || normalized < 1024 || normalized > 65535) {
          showStatus("代理端口无效（范围 1024-65535）", "error", 5000);
          return;
        }

        let currentCfg = null;
        try {
          currentCfg = await api.get("/proxy/config");
        } catch {
          currentCfg = null;
        }

        const inboundMode = currentCfg && currentCfg.inboundMode ? currentCfg.inboundMode : "mixed";

        // TUN 模式下端口不生效，但仍可提前保存到配置中（切回非 TUN 时生效）。
        if (inboundMode === "tun") {
          try {
            await api.put("/proxy/config", { inboundPort: normalized });
            showStatus("已保存代理端口（当前为 TUN 模式，切回非 TUN 后生效）", "info", 4000);
          } catch (err) {
            showStatus(`保存代理端口失败：${err.message}`, "error", 6000);
          }
          return;
        }

        // 非 TUN：强制保持 mixed（系统代理场景需要 HTTP + SOCKS）
        try {
          await api.put("/proxy/config", { inboundMode: "mixed", inboundPort: normalized });
        } catch (err) {
          showStatus(`保存代理端口失败：${err.message}`, "error", 6000);
          return;
        }

        // 如果内核正在运行，需要重启才能让端口变更生效。
        let status = null;
        try {
          status = await api.proxy.status();
          coreStatus = status || coreStatus;
        } catch {
          status = null;
        }

        const running = Boolean(status && status.running);
        if (running) {
          const frouterId = (status && status.frouterId) ? status.frouterId : (getCurrentFRouter()?.id || "");
          if (!frouterId) {
            showStatus("已更新端口，但无法自动重启：请先选择一个 FRouter", "warn", 6000);
            return;
          }

          showStatus("正在应用代理端口（重启内核）...", "info", 2000);
          try {
            await api.post("/proxy/start", { frouterId });
            await new Promise((r) => setTimeout(r, 500));
          } catch (err) {
            showStatus(`重启内核失败：${err.message}`, "error", 6000);
            return;
          }

          // 系统代理已启用时，重启后需要重新应用系统代理（端口可能发生变化）。
          if (systemProxySettings && systemProxySettings.enabled) {
            try {
              await api.put("/settings/system-proxy", {
                enabled: true,
                ignoreHosts: collectIgnoreHosts(),
              });
            } catch (err) {
              console.warn("[SystemProxy] 重新应用系统代理失败:", err.message);
            }
          }
        }

        await refreshCoreStatus();
        await loadSystemProxySettings();
        await loadIPGeo();

        // 提示端口更新结果
        try {
          const latest = await api.proxy.status();
          if (latest && latest.running) {
            showStatus(`代理端口已更新为 ${normalized}`, "success", 2000);
          } else {
            showStatus(`代理端口已更新为 ${normalized}`, "success", 2000);
          }
        } catch {
          showStatus(`代理端口已更新为 ${normalized}`, "success", 2000);
        }
      }

      // 监听设置变化，保存到后端 API
      let saveTimeout = null;
      for (const category of SETTINGS_SCHEMA.categories) {
        for (const setting of category.settings) {
          settingsManager.on(setting.key, (value, oldValue, key) => {
            // 防抖：300ms 内只保存一次
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(async () => {
              await settingsManager.saveToAPI(api.client.baseURL);
            }, 300);

            // 特殊联动：系统代理端口 -> 后端 ProxyConfig.inboundPort
            if (key === "proxy.port") {
              if (proxyPortApplyTimeout) clearTimeout(proxyPortApplyTimeout);
              proxyPortApplyTimeout = setTimeout(async () => {
                await applyProxyPortSetting(value);
              }, 300);
            }
          });
        }
      }

      // 从后端 API 加载已保存的设置
      (async function loadSettingsFromAPI() {
        await settingsManager.loadFromAPI(api.client.baseURL);
        await syncProxyPortFromBackend();
        renderAllSettings();
      })();

      const componentTable = document.getElementById("component-table");
      if (componentTable) {
        componentTable.addEventListener("click", async (event) => {
          const button = event.target.closest("button[data-action]");
          if (!button) return;
          const tr = button.closest("tr[data-id]");
          if (!tr) return;
          const id = tr.dataset.id;
          const kind = tr.dataset.kind;
          const action = button.dataset.action;
          try {
            if (action === "delete-component") {
              if (!confirm("确认删除该组件？")) return;
              await api.delete(`/components/${id}`);
              showStatus("组件已删除", "success");
              await loadComponents();
              await refreshCoreStatus();
            } else if (action === "uninstall-component") {
              if (!confirm("确认卸载该组件？这将删除本地安装文件。")) return;
              await api.post(`/components/${id}/uninstall`);
              showStatus("组件已卸载", "success");
              await loadComponents();
              await refreshCoreStatus();
            } else if (action === "update-component") {
              if (kind) {
                await ensureComponent(kind);
              } else {
                showStatus("无法识别组件类型", "error");
              }
            }
          } catch (err) {
            showStatus(`组件操作失败：${err.message}`, "error", 6000);
          }
        });
      }

      document.querySelectorAll(".ensure-component").forEach((button) => {
        button.addEventListener("click", async () => {
          const kind = button.dataset.kind;
          if (!kind) return;
          button.disabled = true;
          try {
            await ensureComponent(kind);
          } finally {
            button.disabled = false;
          }
        });
      });

      // Initial load
      loadFRouters();
      loadNodes();
      loaders[currentPanel]?.();
      ensureFRoutersPolling();
    })();

    // 窗口控制按钮事件
    if (window.electronAPI) {
      document.getElementById('minimize-btn').addEventListener('click', () => {
        window.electronAPI.minimizeWindow();
      });

      document.getElementById('maximize-btn').addEventListener('click', () => {
        window.electronAPI.maximizeWindow();
      });

      document.getElementById('close-btn').addEventListener('click', () => {
        window.electronAPI.closeWindow();
      });
    }

    // Theme settings - Switch between HTML files
    // Theme selector
    const themeSelector = document.getElementById("theme-selector");

    function switchTheme(theme) {
      localStorage.setItem("theme", theme);
      const file = theme === "dark" ? "dark.html" : "light.html";
      window.location.href = file;
    }

    // Get current theme from filename
    const currentFile = window.location.pathname.split('/').pop();
    const currentTheme = currentFile.includes('light') ? 'light' : 'dark';

    // Check if saved theme is different from current loaded theme
    const savedTheme = localStorage.getItem("theme") || "dark";
    if (savedTheme !== currentTheme) {
      // Auto-redirect to saved theme
      switchTheme(savedTheme);
    }

    // Set selector value to current theme
    if (themeSelector) {
      themeSelector.value = currentTheme;

      // Listen for theme changes
      themeSelector.addEventListener("change", (e) => {
        switchTheme(e.target.value);
      });
    }
  </script>
</body>

</html>
