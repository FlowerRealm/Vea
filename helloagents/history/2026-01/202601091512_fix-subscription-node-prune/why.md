# 变更提案: 修复订阅节点自动清理（避免节点越积越多）

## 需求背景
当前订阅“拉取节点”/自动同步会把解析出的节点 upsert 到 Node 仓储，但不会删除订阅中已不存在的旧节点。
当订阅内容变更（节点轮换、订阅链接更换、策略变化）时，旧节点会一直保留，导致节点列表越来越多，影响选择与管理。

## 变更内容
1. 将 `ReplaceNodesForConfig` 恢复为“替换语义”：当传入非空节点集合时，视为最新快照并删除不在快照内的历史节点。
2. 保留显式清空语义：`nodes == nil`（`domain.ClearNodes`）时清空该 config 的全部节点。
3. 保留“空集合不删”的安全阀：`len(nodes) == 0` 时不触发删除，用于调用方表达“本次不更新节点集合”（订阅解析失败/空内容仍由上层拦截）。

## 影响范围
- **模块:** backend
- **文件:**
  - `backend/repository/memory/node_repo.go`
  - `backend/repository/memory/node_repo_test.go`
- **API:** 无变化
- **数据:** 订阅节点在下一次成功拉取后会被按快照清理（历史冗余节点会被删除）

## 核心场景

### 需求: 订阅节点不再无限增长
**模块:** backend  
订阅内容变更后，节点集合应与订阅快照一致，避免历史节点累积。

#### 场景: 拉取订阅节点后清理旧节点
- 条件: 同一 `configID` 先后两次拉取到的节点集合不同
- 预期结果:
  - 新快照中不存在的旧节点会被删除
  - 新快照中仍存在的节点保留其运行期指标与用户自定义名称/标签

## 风险评估
- **风险:** 订阅服务偶发返回不完整节点列表时，可能导致旧节点被删除。
- **缓解:**
  - 上层订阅同步在 payload 为空或解析失败时不会调用替换逻辑（仍保留现有节点）。
  - 删除逻辑仅在 `len(nodes) > 0` 的“成功解析出节点”场景触发。
