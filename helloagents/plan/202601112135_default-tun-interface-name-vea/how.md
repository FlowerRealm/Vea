# 技术设计: 默认 TUN 网卡名改为 vea

## 技术方案

### 核心技术
- Go 后端：默认值、TUN 就绪判定、内核配置生成（sing-box/mihomo）
- 前端：设置 schema 默认值（零依赖 JS）

### 实现要点
- **默认值统一**
  - 将后端 `defaultTunInterfaceName` 从 `tun0` 调整为 `vea`，并保持与前端 schema 一致。
- **非 Linux 平台保持“不强制默认名称”策略**
  - 当 `tunSettings.interfaceName` 为默认值 `vea` 时：
    - sing-box：不写 `tun.interface_name`（留空自动选择）
    - mihomo：不写 `tun.device`（留空自动选择）
    - 后端 readiness：按 TUN 地址识别实际网卡，不依赖名称
- **兼容旧默认值 `tun0`（避免回归）**
  - 在非 Linux 平台将 `tun0` 视为 legacy 默认占位值，行为与默认 `vea` 一致（不写死名称 / readiness 按地址）。
  - 在 Linux 平台保持 `tun0` 作为合法可用的显式设备名（不做强制迁移）。
- **前端默认值更新**
  - `tun.interfaceName` 默认值从 `tun0` 改为 `vea`（三处 schema 保持一致）。
- **文档与知识库同步**
  - 更新对外文档与知识库中关于默认值/行为的描述，避免“文档说 tun0、代码是 vea”的割裂。

## 架构决策 ADR

### ADR-001: 非 Linux 下将 `tun0` 作为 legacy 默认占位值
**上下文:** 默认值从 `tun0` → `vea` 后，历史配置可能仍保存 `tun0`。非 Linux 平台的 TUN 网卡名通常不稳定或不可控，若将 `tun0` 视为“用户自定义名”会回归就绪误判风险。

**决策:** 在 Windows/macOS 路径将 `tun0` 与 `vea` 同等视为“默认占位值”，默认不强制写死名称，并继续按地址判定就绪。

**替代方案:**
- 方案A: 直接不兼容 `tun0`（拒绝原因: 风险高，可能回归已修复的就绪误判）。
- 方案B: 启动时自动迁移并持久化 `tun0` → `vea`（拒绝原因: 需要引入存储层写回与迁移策略，改动面更大且不必要）。

**影响:** 增加少量 legacy 分支判断，但可避免跨平台回归；Linux 行为保持可控与可覆盖。

## API 设计
无 API 结构变更，仅默认值与默认行为调整。

## 数据模型
无数据结构变更；仅需考虑历史配置存在 `tun0` 的情况。

## 安全与性能
- **安全:** 不涉及敏感信息与权限模型变更；保持现有 TUN 提权/检查逻辑不变。
- **性能:** 仅常量与分支判断调整，无显著性能影响。

## 测试与部署
- 单元测试：`go test ./...`
- 重点覆盖：
  - 默认值由 `tun0` → `vea` 的期望更新
  - Windows/macOS 下 `tun0` 与 `vea` 均不写死名称的行为

